<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda do Astr√¥nomo</title>
    <!-- <link rel="stylesheet" href="css/main-responsive.css"> -->
    <link rel="stylesheet" href="css/styles.css">
    <script src="auth.js"></script>

    <!-- Reaproveita o visual da Agenda/RH (ajuste caminhos se necess√°rio) -->
    <!-- <link rel="stylesheet" href="css/main-responsive.css"> -->
    <!-- <link rel="stylesheet" href="css/style.css"> -->
    <!-- <link rel="stylesheet" href="css/docs-app.css"> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> -->
    <!-- <link rel="stylesheet" href="css/agenda.css"> -->
</head>
<body class="presentation-page agenda-page">
    <!-- Fundo gal√°ctico reaproveitado -->
    <div class="space-layer stars"></div>
    <div class="space-layer twinkle"></div>
    <div class="space-layer nebula"></div>
    <div class="space-layer galaxies"></div>

    <div class="page-wrapper">
        <div class="page-container">
            <header class="page-header">
                <div>
                    <h1>üåå Agenda do Astr√¥nomo</h1>
                    <div class="astro-info" id="astro-info">Carregando dados do astr√¥nomo...</div>
                </div>
                <a href="account.html" class="nav-button">
                    <i class="fas fa-user-astronaut"></i> Minha Conta
                </a>
            </header>

            <div class="navigation">
                <a href="index.html" class="nav-button active"><i class="fas fa-calendar-alt"></i> Agenda</a>
                <a href="feedbacks.html" class="nav-button"><i class="fas fa-comment-dots"></i> Feedbacks</a>
                <a href="despesas.html" class="nav-button"><i class="fas fa-file-invoice-dollar"></i> Despesas</a>
                <a href="historico.html" class="nav-button"><i class="fas fa-history"></i> Hist√≥ricos</a>
                <a href="account.html" class="nav-button account-header-btn"><i class="fas fa-user-astronaut"></i> Minha Conta</a>
                <a href="rotas.html" class="nav-button"><i class="fas fa-route"></i> Rotas</a>
                <a href="debug-astronomo.html" class="nav-button"><i class="fas fa-bug"></i> Debug</a>
            </div>

            <div class="panel-card" style="margin-bottom: 12px;">
                <div class="filters-row">
                    <div>
                        <label for="task-type-filter">Tipo de tarefa:</label>
                        <select id="task-type-filter">
                            <option value="all">Todos</option>
                            <option value="visita">Astr√¥nomo VISITA</option>
                            <option value="pre">Astr√¥nomo PR√â</option>
                            <option value="reserva">Astr√¥nomo RESERVA</option>
                            <option value="nao_marcar">Astr√¥nomo N√ÉO MARCAR</option>
                        </select>
                    </div>
                    <button id="btn-refresh-agenda" class="btn btn-secondary">
                        üîÑ Atualizar agenda
                    </button>
                    <button id="btn-open-rotas" class="cta-rotas btn btn-primary" title="Usa os dados carregados aqui para montar as rotas cont√≠nuas">
                        <i class="fas fa-route"></i> Rotas
                    </button>
                    <span class="status-text" id="status-text">Aguardando carregamento...</span>
                </div>
            </div>

            <div class="main-grid">
                <!-- Calend√°rio -->
                <div class="calendar-panel">
                    <div class="panel-card">
                        <div class="panel-title">
                            <span>üìÖ Calend√°rio <span class="info-icon" title="Eventos sem data definida n√£o aparecem no calend√°rio.&#10;Se o calend√°rio estiver vazio, considere que seu dia est√° livre.&#10;&#10;Eventos duplicados foram agrupados para facilitar a visualiza√ß√£o da agenda.&#10;&#10;Cada dia marcado no calend√°rio representa uma di√°ria.&#10;Por isso, eventos com v√°rias di√°rias aparecem ocupando v√°rios dias consecutivos a partir da data de in√≠cio." aria-label="Informa√ß√µes sobre o calend√°rio">‚ÑπÔ∏è</span></span>
                        </div>
                        <div class="calendar-header-row">
                            <button class="calendar-nav-btn btn btn-secondary" id="btn-prev-month">‚Üê M√™s anterior</button>
                            <div class="calendar-month-label" id="current-month-label">...</div>
                            <button class="calendar-nav-btn btn btn-secondary" id="btn-next-month">Pr√≥ximo m√™s ‚Üí</button>
                        </div>
                        <table class="calendar-table">
                            <thead>
                                <tr>
                                    <th>Dom</th>
                                    <th>Seg</th>
                                    <th>Ter</th>
                                    <th>Qua</th>
                                    <th>Qui</th>
                                    <th>Sex</th>
                                    <th>S√°b</th>
                                </tr>
                            </thead>
                            <tbody id="calendar-body">
                                <!-- preenchido via JS -->
                            </tbody>
                        </table>
                        <div class="day-detail" id="day-detail">
                            <div class="day-detail__header">
                                <div class="day-detail__title">
                                    <i class="fas fa-circle-dot"></i>
                                    <span id="day-detail-label">Selecione um dia para ver os eventos</span>
                                </div>
                                <span class="day-detail__count" id="day-detail-count"></span>
                            </div>
                            <div class="day-detail__body" id="day-detail-body">
                                <div class="day-detail__empty">Clique em um dia do calend√°rio para ver os eventos dessa data.</div>
                            </div>
                        </div>
                        <div class="day-weather" id="day-weather">
                            <div class="day-weather__header">
                                <div class="day-weather__title"><i class="fas fa-cloud-sun"></i> Clima do dia</div>
                                <span class="day-weather__meta" id="day-weather-meta">Carregue a agenda para ver a previs√£o.</span>
                            </div>
                            <div class="day-weather__body" id="day-weather-body">
                                <div class="day-weather__empty">Aguardando sele√ß√£o de evento para exibir clima de origem e destino.</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Lista de eventos -->
                <div class="events-panel">
                    <div class="panel-card">
                        <div class="panel-title">
                            <span>üìã Eventos <span class="info-icon" title="Os eventos listados s√£o carregados da agenda.&#10;Clique em um evento para ver detalhes e a√ß√µes dispon√≠veis." aria-label="Informa√ß√µes sobre os eventos">‚ÑπÔ∏è</span></span>
                            <span id="events-count" style="font-size:0.8rem; opacity:0.85;">0 evento(s)</span>
                        </div>
                        <div class="events-list" id="events-list">
                            <div class="empty-state">
                                Aguardando dados da agenda...
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div> <!-- /page-container -->
    </div> <!-- /page-wrapper -->

    <!-- Modal de detalhes do evento -->
    <div class="event-modal" id="event-modal" aria-hidden="true">
        <div class="event-modal-backdrop" id="event-modal-backdrop"></div>
        <div class="event-modal-content">
            <button class="event-modal-close" id="event-modal-close" aria-label="Fechar">‚úï</button>
            <div id="event-modal-body">Carregando...</div>
        </div>
    </div>

    <!-- Lightbox de imagens em tela cheia -->
    <div class="image-lightbox" id="image-lightbox" aria-hidden="true">
        <div class="image-lightbox__backdrop" id="image-lightbox-backdrop"></div>
        <div class="image-lightbox__content">
            <button class="image-lightbox__close" id="image-lightbox-close" aria-label="Fechar imagens">‚úï</button>
            <button class="image-lightbox__nav" id="image-lightbox-prev" aria-label="Imagem anterior">‚Äπ</button>
            <img id="image-lightbox-img" alt="Imagem do evento" loading="lazy" decoding="async">
            <button class="image-lightbox__nav" id="image-lightbox-next" aria-label="Pr√≥xima imagem">‚Ä∫</button>
            <div class="image-lightbox__counter" id="image-lightbox-counter"></div>
        </div>
    </div>

    <script>
        // Limpa caches no reload (F5), preservando apenas sess√µes
        (function(){
            const isReload = (() => {
                try{
                    const nav = performance.getEntriesByType('navigation')[0];
                    if (nav && nav.type) return nav.type === 'reload';
                    if (performance.navigation) return performance.navigation.type === 1;
                }catch(_){}
                return false;
            })();
            if (!isReload) return;
            try{
                const keep = new Set(['astronomo_session','userSession']);
                const prefixes = ['agenda_cache_v1','agenda_payload_v1','rotas_cache_v1','rotas_override_v1','route_cache_osrm_v1','coord_cache_nominatim_v1','route_block_cache_v1'];
                const contains = ['user_theme','savedUser','astronomersData','astronomersLastUpdate'];
                const toDelete = [];
                for (let i=0;i<localStorage.length;i++){
                    const k = localStorage.key(i);
                    if (!k) continue;
                    if (keep.has(k)) continue;
                    if (prefixes.some(p => k.startsWith(p)) || contains.some(c => k.includes(c))) {
                        toDelete.push(k);
                    }
                }
                toDelete.forEach(k => localStorage.removeItem(k));
            }catch(_){}
        })();

        // ==== Configura√ß√£o dos webhooks ====
        const API_EVENT_IMAGES = "https://urania-planetario-n8n.mmjkgs.easypanel.host/webhook/novo-astronomo-1";
        // Cache local para reutilizar os eventos nas demais p√°ginas
        const AGENDA_CACHE_PREFIX = 'agenda_cache_v1';
        const AGENDA_PAYLOAD_PREFIX = 'agenda_payload_v1';
        const ROTAS_CACHE_KEY = 'rotas_cache_v1';
        const ROTA_OVERRIDE_PREFIX = 'rotas_override_v1';
        const WEATHER_API_BASE = 'https://api.open-meteo.com/v1/forecast';
        const WEATHER_GEO_API_BASE = 'https://geocoding-api.open-meteo.com/v1/search';

        function agendaCacheKey(sess){
            const ns = (sess && (sess.id_astronomo ?? sess.usuario ?? sess.username)) || 'anon';
            return `${AGENDA_CACHE_PREFIX}::${String(ns).toLowerCase()}`;
        }

        function saveAgendaCache(events, sess){
            try{
                const key = agendaCacheKey(sess);
                const payload = { ts: Date.now(), events: Array.isArray(events) ? events : [] };
                localStorage.setItem(key, JSON.stringify(payload));
            }catch(err){
                console.warn('Falha ao salvar cache local da agenda:', err);
            }
        }

        function agendaPayloadKey(sess){
            const ns = (sess && (sess.id_astronomo ?? sess.usuario ?? sess.username)) || 'anon';
            return `${AGENDA_PAYLOAD_PREFIX}::${String(ns).toLowerCase()}`;
        }

        function saveAgendaPayload(payload, sess){
            try{
                const key = agendaPayloadKey(sess);
                const pack = { ts: Date.now(), payload: payload ?? null };
                localStorage.setItem(key, JSON.stringify(pack));
            }catch(err){
                console.warn('Falha ao salvar payload bruto da agenda:', err);
            }
        }

        function syncRotasCache(events, sess){
            try{
                const onlyVisita = Array.isArray(events) ? events.filter(isVisitaEvent) : [];
                const payload = {
                    ts: Date.now(),
                    session: sess || null,
                    events: onlyVisita
                };
                localStorage.setItem(ROTAS_CACHE_KEY, JSON.stringify(payload));
            }catch(err){
                console.warn('Falha ao espelhar cache para rotas:', err);
            }
        }

        function rotaOverrideKey(sess){
            const ns = (sess && (sess.id_astronomo ?? sess.usuario ?? sess.username ?? sess.astronomo)) || 'anon';
            return `${ROTA_OVERRIDE_PREFIX}::${String(ns).toLowerCase()}`;
        }

        function saveRouteOverrides(map, sess){
            try{
                const key = rotaOverrideKey(sess);
                const existingRaw = localStorage.getItem(key);
                const existing = existingRaw ? JSON.parse(existingRaw) : {};
                const merged = { ...(existing.overrides || {}), ...(map || {}) };
                const payload = { ts: Date.now(), overrides: merged };
                localStorage.setItem(key, JSON.stringify(payload));
                return payload;
            }catch(err){
                console.warn('Falha ao salvar overrides de rotas:', err);
                return null;
            }
        }

        function loadRouteOverrides(sess){
            try{
                const key = rotaOverrideKey(sess);
                const raw = localStorage.getItem(key);
                return raw ? JSON.parse(raw) : null;
            }catch(_){
                return null;
            }
        }

        // ==== Refer√™ncias DOM ====
        const astroInfoEl        = document.getElementById('astro-info');
        const statusTextEl       = document.getElementById('status-text');
        const taskTypeFilterEl   = document.getElementById('task-type-filter');
        const btnRefreshAgenda   = document.getElementById('btn-refresh-agenda');
        const btnOpenRotas       = document.getElementById('btn-open-rotas');
        const currentMonthLabel  = document.getElementById('current-month-label');
        const calendarBody       = document.getElementById('calendar-body');
        const btnPrevMonth       = document.getElementById('btn-prev-month');
        const btnNextMonth       = document.getElementById('btn-next-month');
        const eventsListEl       = document.getElementById('events-list');
        const eventsCountEl      = document.getElementById('events-count');
        const dayDetailLabel     = document.getElementById('day-detail-label');
        const dayDetailCount     = document.getElementById('day-detail-count');
        const dayDetailBody      = document.getElementById('day-detail-body');
        const dayWeatherEl       = document.getElementById('day-weather');
        const dayWeatherBodyEl   = document.getElementById('day-weather-body');
        const dayWeatherMetaEl   = document.getElementById('day-weather-meta');
        const eventModal         = document.getElementById('event-modal');
        const eventModalBody     = document.getElementById('event-modal-body');
        const eventModalClose    = document.getElementById('event-modal-close');
        const eventModalBackdrop = document.getElementById('event-modal-backdrop');
        if (btnOpenRotas) btnOpenRotas.disabled = true;
        // Lightbox refs
        const lightboxEl         = document.getElementById('image-lightbox');
        const lightboxImg        = document.getElementById('image-lightbox-img');
        const lightboxCounter    = document.getElementById('image-lightbox-counter');
        const lightboxPrev       = document.getElementById('image-lightbox-prev');
        const lightboxNext       = document.getElementById('image-lightbox-next');
        const lightboxClose      = document.getElementById('image-lightbox-close');
        const lightboxBackdrop   = document.getElementById('image-lightbox-backdrop');

        // ==== Estado simples ====
        let eventsData = [];          // eventos normalizados (dedupe)
        let eventsDataRaw = [];       // eventos normalizados (sem dedupe)
        let showDuplicates = false;
        let currentMonthDate = new Date(); // data base do m√™s atual
        let selectedDate = startOfDay(new Date());      // dia selecionado no calend√°rio
        let currentTaskFilter = { type: 'visita', id: null };
        let currentSession = null;
        const WEATHER_CACHE_TTL = 30 * 60 * 1000; // 30 min
        const GEO_CACHE_TTL = 7 * 24 * 60 * 60 * 1000; // 7 dias
        const weatherCache = new Map();
        const geoCache = new Map();
        let weatherRenderToken = 0;
        const INDEX_UI_STATE_KEY = 'index_ui_state_v1';
        const getSelectedTaskFilter = () => {
            if (!taskTypeFilterEl) return { type:'all', id:null };
            const opt = taskTypeFilterEl.selectedOptions[0];
            const type = (opt && (opt.dataset.type || opt.value)) || 'all';
            const idVal = opt && opt.value && opt.value !== 'all' && opt.value !== type ? opt.value : null;
            return { type, id: idVal };
        };
        // Lightbox state
        let lightboxImages = [];
        let lightboxIndex = 0;
        const API_AGENDA = "https://urania-planetario-n8n.mmjkgs.easypanel.host/webhook/agenda-astronomos";

        async function readResponsePayload(resp){
            let text = '';
            try { text = await resp.text(); } catch (_) { text = ''; }
            if (!text) return null;
            try { return JSON.parse(text); } catch (_) { return text; }
        }

        function normalizeAgendaPayload(data){
            if (!data) return [];
            if (Array.isArray(data)) return data;
            if (typeof data !== 'object') return [];
            if (Array.isArray(data.eventos)) return data.eventos;
            if (Array.isArray(data.data)) return data.data;
            if (Array.isArray(data.events)) return data.events;
            if (Array.isArray(data.agenda)) return data.agenda;
            return [data];
        }

        function getWebhookTipoFromSelect(){
            // Sempre solicita TODOS do webhook; o filtro por tipo √© aplicado no frontend.
            return 'TODOS';
        }

        function saveIndexUIState(){
            try{
                const state = {
                    month: currentMonthDate ? currentMonthDate.toISOString() : null,
                    selectedDate: selectedDate ? selectedDate.toISOString() : null,
                    taskFilter: taskTypeFilterEl ? taskTypeFilterEl.value : 'visita'
                };
                localStorage.setItem(INDEX_UI_STATE_KEY, JSON.stringify(state));
            }catch(_){}
        }

        function loadIndexUIState(){
            try{
                const raw = localStorage.getItem(INDEX_UI_STATE_KEY);
                if (!raw) return null;
                const s = JSON.parse(raw);
                return s;
            }catch(_){ return null; }
        }

        function pickAstronomoId(obj){
            if (!obj || typeof obj !== 'object') return null;
            const candidates = [
                obj.id_astronomo,
                obj.astronomo_id,
                obj.id,
                obj.user_id,
                obj.usuario_id,
                obj.assistant_id, // fallback, se API usar esse ID
                obj.row_number,
                obj.row_num,
            ];
            for (const v of candidates){
                if (v === undefined || v === null || v === '') continue;
                const num = Number(v);
                if (Number.isFinite(num)) return num;
                return v; // se vier como string n√£o num√©rica, ainda assim retorna
            }
            return null;
        }

        // ==== Util: sess√£o do login (reaproveitando astronomo_session) ====
        function getLoggedSession(){
            const normalizeSession = (src) => {
                if (!src || typeof src !== 'object') return null;
                const base = { ...src };
                // Se dentro existir objeto astronomer (formato do userSession), mescla
                if (src.astronomer && typeof src.astronomer === 'object') {
                    Object.assign(base, src.astronomer);
                    if (!base.usuario && src.astronomer.usuario) base.usuario = src.astronomer.usuario;
                    if (!base.nome_completo && src.astronomer.nome_completo) base.nome_completo = src.astronomer.nome_completo;
                }
                const id = pickAstronomoId(base);
                const normalized = {
                    loggedIn: src.loggedIn === true || src.loginTime != null || src.token != null,
                    username: base.usuario || base.username || base.astronomo || base.nome_completo || src.username || src.user || null,
                    usuario: base.usuario || base.username || base.astronomo || null,
                    id_astronomo: id,
                    id_visita: base.id_visita ?? base.visita_id ?? null,
                    id_pre: base.id_pre ?? base.pre_id ?? null,
                    id_reserva: base.id_reserva ?? base.reserva_id ?? null,
                    id_n_marcar: base.id_n_marcar ?? base.id_nao_marcar ?? base.nao_marcar_id ?? null,
                    assistant_id: base.assistant_id ?? null,
                    row_number: base.row_number ?? base.row_num ?? null,
                    sessionId: src.sessionId ?? src.session_id ?? src.token ?? null,
                    session_id: src.session_id ?? src.sessionId ?? src.token ?? null,
                    timestamp: src.timestamp ?? Date.now(),
                    nome_completo: base.nome_completo ?? base.usuario ?? null,
                };
                return normalized;
            };

            try {
                const raw = localStorage.getItem('astronomo_session');
                const s = raw ? JSON.parse(raw) : null;
                const norm = normalizeSession(s);
                if (norm && norm.loggedIn && norm.id_astronomo != null) return norm;
                if (norm && norm.loggedIn && norm.id_astronomo == null) {
                    // tenta salvar de volta se conseguir derivar depois
                    localStorage.setItem('astronomo_session', JSON.stringify(norm));
                }
            } catch (e) { /* ignora */ }

            // Fallback: se existir a sess√£o antiga (userSession) vinda do login,
            // tenta normalizar para astronomo_session.
            try {
                const legacyRaw = localStorage.getItem('userSession');
                const legacySess = legacyRaw ? JSON.parse(legacyRaw) : null;
                const normalized = normalizeSession(legacySess);
                if (normalized && normalized.loggedIn && normalized.id_astronomo != null) {
                    localStorage.setItem('astronomo_session', JSON.stringify(normalized));
                    return normalized;
                }
            } catch (_) { /* ignora */ }
            return null;
        }

        function describeSession(sess){
            if (!sess) return 'Nenhum astr√¥nomo logado.';
            const nome = sess.nome_completo || sess.astronomo || sess.usuario || sess.username || 'Astr√¥nomo';
            const id   = sess.id_astronomo != null ? `ID ${sess.id_astronomo}` : '';
            return `${nome}${id ? ' ¬∑ ' + id : ''}`;
        }

        function findAstronomerFromCache(sess){
            try{
                const raw = localStorage.getItem('astronomersData');
                const list = raw ? JSON.parse(raw) : null;
                if (!Array.isArray(list) || !list.length) return null;
                const id = sess?.id_astronomo ?? sess?.assistant_id ?? sess?.id ?? null;
                const user = (sess?.usuario || sess?.username || sess?.astronomo || '').toString().trim().toLowerCase();
                return list.find(a => {
                    if (!a || typeof a !== 'object') return false;
                    const aId = a.id_astronomo ?? a.id ?? a.assistant_id ?? null;
                    if (id != null && String(aId) === String(id)) return true;
                    const aUser = (a.usuario || a.username || a.astronomo || '').toString().trim().toLowerCase();
                    return user && aUser && aUser === user;
                }) || null;
            }catch(_){
                return null;
            }
        }

        function buildSessionPayload(sess){
            const cached = findAstronomerFromCache(sess);
            return { ...(cached || {}), ...(sess || {}) };
        }

        // ==== Util: normalizar tipo de tarefa em categoria (visita, pre, reserva, nao_marcar, outros) ====
        function classifyTaskType(rawTipo){
            if (!rawTipo) return 'outros';
            const t = String(rawTipo)
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .replace(/√±/gi, 'n')
                .toLowerCase()
                .trim();
            if (t.includes('visita')) return 'visita';
            if (t.includes('pre') || t.includes('pre ')) return 'pre';
            if (t.includes('reserva')) return 'reserva';
            if (t.includes('nao marcar') || t.includes('nao_marcar') || t.includes('n marcar')) return 'nao_marcar';
            return 'outros';
        }

        function getSessionTaskIds(sess){
            const base = buildSessionPayload(sess);
            const parseId = (v) => {
                if (v === undefined || v === null || v === '') return null;
                const n = toNumber(v);
                if (n !== null) return String(n);
                const s = String(v).trim();
                return s || null;
            };
            return {
                visita: parseId(base?.id_visita || base?.visita_id),
                pre: parseId(base?.id_pre || base?.pre_id),
                reserva: parseId(base?.id_reserva || base?.reserva_id),
                nao_marcar: parseId(base?.id_n_marcar || base?.id_nao_marcar || base?.nao_marcar_id)
            };
        }

        // ==== Util: campo din√¢mico por usu√°rio (ex.: json.<usuario>_VISITA) ====
        function normalizeFieldName(str){
            return String(str || '')
                .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                .trim().toLowerCase()
                .replace(/[\s-]+/g, '_');
        }

        function getUserTaskType(event, session){
            if (!event || typeof event !== 'object') return null;
            const userRaw = (session && (session.usuario || session.username || session.astronomo)) || '';
            const userKey = normalizeFieldName(userRaw);
            if (!userKey) return null;

            const prefix = `${userKey}_`;
            for (const originalKey of Object.keys(event)) {
                const normalizedKey = normalizeFieldName(originalKey);
                if (!normalizedKey.startsWith(prefix)) continue;

                const value = event[originalKey];
                const hasValue = value !== undefined && value !== null && String(value).trim() !== '';
                if (!hasValue) continue;

                const suffix = normalizedKey.slice(prefix.length);
                if (suffix === 'visita') return 'visita';
                if (suffix === 'pre') return 'pre';
                if (suffix === 'reserva') return 'reserva';
                if (suffix === 'nao_marcar') return 'nao_marcar';
            }
            return null;
        }

        // ==== Util: pegar data do evento ====
        function getEventDate(ev){
            const raw = ev.data_e_hora_agendamento || ev.data_e_hora_do_agendamento || ev.data_agendamento || ev.data || ev.date;
            if (!raw) return null;
            const d = new Date(raw);
            if (Number.isNaN(d.getTime())) return null;
            return new Date(d.getFullYear(), d.getMonth(), d.getDate());
        }

        function sameDay(d1, d2){
            return d1.getFullYear() === d2.getFullYear() &&
                   d1.getMonth()    === d2.getMonth() &&
                   d1.getDate()     === d2.getDate();
        }

        function dateKey(d){
            if (!(d instanceof Date) || Number.isNaN(d.getTime())) return '';
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, '0');
            const dd = String(d.getDate()).padStart(2, '0');
            return `${y}-${m}-${dd}`;
        }

        function parseDateKey(str){
            if (!str || typeof str !== 'string') return null;
            const parts = str.split('-').map(Number);
            if (parts.length !== 3 || parts.some(n => !Number.isFinite(n))) return null;
            const [y, m, d] = parts;
            return new Date(y, m - 1, d);
        }

        function formatDateBr(d){
            if (!(d instanceof Date) || Number.isNaN(d.getTime())) return 'Data indefinida';
            return d.toLocaleDateString('pt-BR', { weekday:'short', day:'2-digit', month:'2-digit' });
        }

        function formatMonthYearBr(d){
            return d.toLocaleDateString('pt-BR', { month:'long', year:'numeric' });
        }

        function normalizeCityUF(str){
            if (!str) return '';
            const tokens = String(str).split('-').map(s => s.trim()).filter(Boolean);
            if (!tokens.length) return '';
            const city = tokens[0];
            const uf = tokens.find(t => t.length === 2 && /^[A-Za-z]{2}$/.test(t)) || tokens[1];
            return uf ? `${city} - ${uf.toUpperCase()}` : city;
        }

        function getSessionCityLabel(sess){
            const raw = sess?.cidade_base
                || sess?.cidade
                || sess?.cidade_origem
                || sess?.base
                || sess?.origem_real
                || sess?.origem
                || sess?.origem_cidade
                || sess?.cidade_base_astronomo
                || sess?.cidade_astronomo
                || sess?.astronomo_cidade
                || '';
            return normalizeCityUF(raw);
        }

        function normalizeGeoQuery(label){
            if (!label) return '';
            let q = String(label).replace(/\s+/g, ' ').trim();
            if (!q) return '';
            q = q.replace(/\s*-\s*/g, ', ');
            if (!/brasil|brazil/i.test(q)) q = `${q}, Brasil`;
            return q;
        }

        async function geocodeCity(label){
            const query = normalizeGeoQuery(label);
            if (!query) return null;
            const key = query.toLowerCase();
            const cached = geoCache.get(key);
            if (cached && (Date.now() - cached.ts) < GEO_CACHE_TTL) return cached.data;

            const url = `${WEATHER_GEO_API_BASE}?name=${encodeURIComponent(query)}&count=1&language=pt&format=json&country_code=BR`;
            const resp = await fetch(url, { headers:{'Accept':'application/json'}, method:'GET' });
            const body = await resp.text().catch(()=> '');
            if (!resp.ok) throw new Error(body || 'Falha ao localizar cidade');
            let data = null;
            try{ data = body ? JSON.parse(body) : null; }catch(_){ data = null; }
            const first = data && Array.isArray(data.results) ? data.results[0] : null;
            if (!first) return null;

            const lat = Number(first.latitude);
            const lon = Number(first.longitude);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            const name = first.name ? String(first.name) : '';
            const admin = first.admin1 ? String(first.admin1) : '';
            const labelOut = name ? (admin ? `${name} - ${admin}` : name) : label;
            const parsed = { lat, lon, label: labelOut };
            geoCache.set(key, { ts: Date.now(), data: parsed });
            return parsed;
        }

        function formatOrigemDestino(ev){
            const origem = normalizeCityUF(ev.cidade_base || ev.origem_real || ev.base || '');
            const destino = normalizeCityUF(ev.cidade_destino || ev.cidade || '');
            if (origem && destino) return `${origem} ‚Üí ${destino}`;
            if (destino) return `‚Üí ${destino}`;
            return origem || 'Local n√£o informado';
        }

        function formatCurrencyBR(val){
            const n = Number(val);
            if (!Number.isFinite(n)) return '‚Äî';
            return n.toLocaleString('pt-BR', { style:'currency', currency:'BRL' });
        }

        function formatDurationHours(val){
            const n = Number(val);
            if (!Number.isFinite(n)) return null;
            if (n >= 24) return `${(n/24).toFixed(1)} dia(s)`;
            return `${n.toFixed(1)} h`;
        }

        function getDurationLabel(ev){
            const override = ev && ev._dur_override_h;
            const candidates = [override, ev?.duracao_horas, ev?.duracao, ev?.duration_hours];
            let raw = null;
            for (const v of candidates){
                const n = Number(v);
                if (Number.isFinite(n)) { raw = n; break; }
            }
            if (raw === null) return null;
            const isContinua = ev.rota_continua === true || ev.rota_continua === 'true' || ev.rota === true || ev.continua === true;
            const adjusted = isContinua ? raw : raw * 2; // ida e volta quando n√£o √© rota cont√≠nua
            const formatted = formatDurationHours(adjusted);
            if (!formatted) return null;
            return isContinua ? formatted : `${formatted} (ida e volta)`;
        }

        function getResultadoLabel(ev){
            const raw = ev && (ev.resultado ?? ev.result ?? ev.status_resultado);
            const s = raw === null || raw === undefined ? '' : String(raw).trim();
            return s || 'Resultado n√£o informado';
        }

        function formatCoord(val){
            const n = Number(val);
            if (!Number.isFinite(n)) return '‚Äî';
            return n.toFixed(5);
        }

        function parseNum(v){
            if (v==null) return 0;
            if (typeof v === 'number' && isFinite(v)) return v;
            const s = String(v);
            const m = s.match(/-?\d{1,3}(?:[\.\s]\d{3})*(?:[\.,]\d+)?|-?\d+(?:[\.,]\d+)?/);
            if (!m) return 0;
            let num = m[0].trim();
            if (num.includes('.') && num.includes(',')) num = num.replace(/\./g,'').replace(',', '.');
            else if (num.includes(',')) num = num.replace(',', '.');
            else num = num.replace(/\s+/g,'');
            const n = Number(num);
            return isFinite(n) ? n : 0;
        }

        const eventColorMap = new Map();
        function hashCode(str){
            let h = 0;
            for (let i = 0; i < str.length; i++) {
                h = ((h << 5) - h) + str.charCodeAt(i);
                h |= 0;
            }
            return h;
        }
        function colorForEvent(id){
            const key = String(id || '');
            if (eventColorMap.has(key)) return eventColorMap.get(key);
            const h = Math.abs(hashCode(key)) % 360;
            const color = `hsl(${h}, 75%, 60%)`;
            eventColorMap.set(key, color);
            return color;
        }

        function updateTaskFilterLabels(sess){
            if (!taskTypeFilterEl) return;
            const ids = getSessionTaskIds(sess);
            const mapping = [
                { key:'visita', label:'VISITA', id: ids.visita },
                { key:'pre', label:'PR√â', id: ids.pre },
                { key:'reserva', label:'RESERVA', id: ids.reserva },
                { key:'nao_marcar', label:'N√ÉO MARCAR', id: ids.nao_marcar },
            ];

            const opts = taskTypeFilterEl.querySelectorAll('option');
            opts.forEach(opt => {
                if (opt.value !== 'all') opt.remove();
            });

            mapping.forEach(item => {
                const opt = document.createElement('option');
                opt.value = item.id || item.key;
                opt.dataset.type = item.key;
                opt.textContent = item.id ? `${item.label} (${item.id})` : item.label;
                taskTypeFilterEl.appendChild(opt);
            });

            const visitaOpt = taskTypeFilterEl.querySelector('option[data-type="visita"]');
            if (visitaOpt) {
                visitaOpt.selected = true;
            } else {
                taskTypeFilterEl.value = 'visita';
            }
        }

        function resolveTaskType(event, session, fallbackTipo){
            const ids = getSessionTaskIds(session);
            const candidate = event.id_tipo_tarefa ?? event.id_tipo ?? event.tipo_id ?? event.tipo_tarefa_id ?? fallbackTipo;
            const candidateStr = candidate !== undefined && candidate !== null ? String(candidate) : null;

            const checkById = (idStr) => {
                if (!idStr) return null;
                if (ids.visita && ids.visita === idStr) return 'visita';
                if (ids.pre && ids.pre === idStr) return 'pre';
                if (ids.reserva && ids.reserva === idStr) return 'reserva';
                if (ids.nao_marcar && ids.nao_marcar === idStr) return 'nao_marcar';
                return null;
            };

            const byId = checkById(candidateStr);
            if (byId) return { type: byId, id: candidateStr };

            const userType = getUserTaskType(event, session);
            if (userType) return { type: userType, id: null };

            // Prefere um campo textual (com letras) para classificar o tipo
            const pickText = (...vals) => {
                for (const v of vals) {
                    const s = v !== undefined && v !== null ? String(v).trim() : '';
                    if (!s) continue;
                    if (/[a-zA-Z\u00C0-\u017F]/.test(s)) return s;
                }
                return vals.find(v => v !== undefined && v !== null) || '';
            };
            const textSource = pickText(
                event.tipo_da_tarefa,
                event.tipo_evento,
                event.tipo,
                event.TIPO,
                fallbackTipo,
                candidateStr
            );
            const textType = classifyTaskType(textSource);
            return { type: textType, id: null };
        }

        function formatTaskLabel(taskType){
            const map = {
                visita: 'VISITA',
                pre: 'PR√â',
                reserva: 'RESERVA',
                nao_marcar: 'N√ÉO MARCAR'
            };
            return map[taskType] || '‚Äî';
        }

        function toNumber(val){
            if (val === null || val === undefined) return null;
            if (typeof val === 'number') return Number.isFinite(val) ? val : null;
            const str = String(val).trim();
            if (!str) return null;

            // Captura n√∫meros em formatos brasileiros (com v√≠rgula) ou com milhares
            const match = str.match(/-?\d{1,3}(?:[.\s]\d{3})*(?:[.,]\d+)?|-?\d+(?:[.,]\d+)?/);
            if (!match) return null;

            let numStr = match[0].replace(/\s+/g, '');
            if (numStr.includes(',') && numStr.includes('.')) {
                // 1.234,56 -> 1234.56
                numStr = numStr.replace(/\./g, '').replace(',', '.');
            } else if (numStr.includes(',')) {
                numStr = numStr.replace(',', '.');
            }

            const n = Number(numStr);
            return Number.isFinite(n) ? n : null;
        }

        function getDistanceKmValue(ev, includeOverride = true){
            const routeInfo = ev && ev.routeInfo ? ev.routeInfo : {};
            const candidates = [
                includeOverride ? ev && ev._dist_override_km : null,
                routeInfo.distanceKm,
                routeInfo.distance_km,
                routeInfo.distancia_km,
                ev && ev.distancia_km,
                ev && ev.distance_km,
                ev && ev.distancia,
                ev && ev.distance,
                ev && ev.km,
                ev && ev.km_total,
                ev && ev.distancia_prevista,
                ev && ev.rota_distancia_km
            ];
            for (const val of candidates){
                const num = toNumber(val);
                if (num !== null) return num;
            }
            return null;
        }

        function formatYesNo(val){
            if (val === null || val === undefined || val === '') return 'N√£o informado';
            if (typeof val === 'string'){
                const s = val.trim().toLowerCase();
                if (['sim','true','1','yes','y','ok'].includes(s)) return 'Sim';
                if (['nao','n√£o','false','0','no','n'].includes(s)) return 'N√£o';
            }
            if (val === true || val === 1) return 'Sim';
            if (val === false || val === 0) return 'N√£o';
            return String(val);
        }

        function computeDistanceKm(lat1, lon1, lat2, lon2){
            const toRad = (deg) => deg * Math.PI / 180;
            const r = 6371;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return r * c;
        }

        function getDistanceLabel(ev){
            const isContinua = ev.rota_continua === true || ev.rota_continua === 'true' || ev.rota === true || ev.continua === true;
            const overrideNum = toNumber(ev && ev._dist_override_km);
            const baseDist = overrideNum !== null ? overrideNum : getDistanceKmValue(ev, false);
            if (baseDist !== null) {
                const adjusted = isContinua ? baseDist : baseDist * 2; // ida e volta quando n√£o √© rota cont√≠nua
                return `${adjusted.toFixed(1)} km${isContinua ? '' : ' (ida e volta)'}`;
            }

            const oLat = toNumber(ev.origem_lat ?? ev.lat_origem ?? ev.latitude_origem);
            const oLon = toNumber(ev.origem_lon ?? ev.lon_origem ?? ev.longitude_origem);
            const dLat = toNumber(ev.destino_lat ?? ev.lat_destino ?? ev.latitude_destino);
            const dLon = toNumber(ev.destino_lon ?? ev.lon_destino ?? ev.longitude_destino);
            if (oLat === null || oLon === null || dLat === null || dLon === null) return '‚Äî';
            const dist = computeDistanceKm(oLat, oLon, dLat, dLon);
            const adjustedCoordDist = isContinua ? dist : dist * 2;
            return `${adjustedCoordDist.toFixed(1)} km${isContinua ? '' : ' (ida e volta)'}`;
        }

        // ==== Previs√£o do tempo (Open-Meteo) ====
        function extractEventLocations(ev, sess){
            const sessionLabel = getSessionCityLabel(sess || {});
            const origemLabel = normalizeCityUF(
                ev?.cidade_base ||
                ev?.origem_real ||
                ev?.base ||
                ev?.cidade_origem ||
                ev?.origem ||
                ev?.origem_cidade ||
                ev?.cidade_base_astronomo ||
                ev?.cidade_astronomo ||
                ev?.astronomo_cidade ||
                ev?.local_origem ||
                ''
            ) || sessionLabel;
            const destinoLabel = normalizeCityUF(
                ev?.cidade_destino ||
                ev?.cidade ||
                ev?.destino ||
                ev?.cidade_evento ||
                ev?.cidade_lead ||
                ev?.cidade_da_escola ||
                ''
            );
            const origem = {
                lat: toNumber(ev?.origem_lat ?? ev?.lat_origem ?? ev?.latitude_origem),
                lon: toNumber(ev?.origem_lon ?? ev?.lon_origem ?? ev?.longitude_origem),
                label: origemLabel
            };
            const destino = {
                lat: toNumber(ev?.destino_lat ?? ev?.lat_destino ?? ev?.latitude_destino ?? ev?.lat),
                lon: toNumber(ev?.destino_lon ?? ev?.lon_destino ?? ev?.longitude_destino ?? ev?.lon),
                label: destinoLabel
            };
            return { origem, destino };
        }

        function hasValidCoords(point){
            return point && Number.isFinite(point.lat) && Number.isFinite(point.lon);
        }

        function describeWeatherCode(code){
            const map = {
                0:'C√©u limpo', 1:'Principalmente limpo', 2:'Parcialmente nublado', 3:'Nublado',
                45:'Neblina', 48:'Neblina',
                51:'Garoa leve', 53:'Garoa moderada', 55:'Garoa densa',
                56:'Garoa congelante leve', 57:'Garoa congelante',
                61:'Chuva fraca', 63:'Chuva moderada', 65:'Chuva forte',
                66:'Chuva congelante', 67:'Chuva forte congelante',
                71:'Neve fraca', 73:'Neve', 75:'Neve intensa',
                77:'Cristais de gelo',
                80:'Pancadas leves', 81:'Pancadas moderadas', 82:'Pancadas fortes',
                85:'Pancadas de neve leve', 86:'Pancadas de neve forte',
                95:'Tempestade', 96:'Tempestade com granizo', 99:'Tempestade forte com granizo'
            };
            return map[code] || 'Condi√ß√£o n√£o informada';
        }

        function extractPrecipitationProbability(data){
            const times = (data && data.hourly && Array.isArray(data.hourly.time)) ? data.hourly.time : [];
            const probs = (data && data.hourly && Array.isArray(data.hourly.precipitation_probability)) ? data.hourly.precipitation_probability : [];
            if (!probs.length) return null;
            const cur = data && data.current_weather && data.current_weather.time;
            const idx = cur ? times.indexOf(cur) : -1;
            const val = idx >= 0 ? probs[idx] : probs[0];
            const num = toNumber(val);
            return Number.isFinite(num) ? num : null;
        }

        async function fetchWeather(lat, lon){
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) throw new Error('Coordenadas inv√°lidas para clima');
            const key = `${lat.toFixed(2)},${lon.toFixed(2)}`;
            const cached = weatherCache.get(key);
            if (cached && (Date.now() - cached.ts) < WEATHER_CACHE_TTL) return cached.data;

            const url = `${WEATHER_API_BASE}?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=temperature_2m,precipitation_probability&forecast_days=1&timezone=auto`;
            const resp = await fetch(url, { headers:{'Accept':'application/json'}, method:'GET' });
            const body = await resp.text().catch(()=> '');
            if (!resp.ok) throw new Error(body || 'Falha ao buscar clima');
            let data = null;
            try{ data = body ? JSON.parse(body) : null; }catch(_){ data = null; }
            if (!data) throw new Error('Resposta de clima vazia');

            const cw = data.current_weather || {};
            const precipitation = extractPrecipitationProbability(data);
            const parsed = {
                temperature: cw.temperature != null ? Number(cw.temperature) : null,
                wind: cw.windspeed != null ? Number(cw.windspeed) : null,
                weathercode: cw.weathercode,
                description: describeWeatherCode(cw.weathercode),
                precipitation,
                time: cw.time || null
            };
            weatherCache.set(key, { ts: Date.now(), data: parsed });
            return parsed;
        }

        function pickEventForWeather(dayEvents, sess){
            if (!Array.isArray(dayEvents) || !dayEvents.length) return null;
            const withLocation = dayEvents.find(ev => {
                const locs = extractEventLocations(ev, sess);
                return hasValidCoords(locs.origem) || hasValidCoords(locs.destino) || !!locs.origem.label || !!locs.destino.label;
            });
            return withLocation || dayEvents[0];
        }

        async function renderWeatherForSelection(dayEvents){
            if (!dayWeatherEl || !dayWeatherBodyEl || !dayWeatherMetaEl) return;
            const token = ++weatherRenderToken;

            if (!Array.isArray(dayEvents) || !dayEvents.length) {
                dayWeatherMetaEl.textContent = 'Sem eventos para esta data';
                dayWeatherBodyEl.innerHTML = `<div class="day-weather__empty">Aguardando eventos com coordenadas para mostrar o clima.</div>`;
                return;
            }

            const visitaEvents = dayEvents.filter(isVisitaEvent);
            if (!visitaEvents.length) {
                dayWeatherMetaEl.textContent = 'Clima apenas para VISITA';
                dayWeatherBodyEl.innerHTML = `<div class="day-weather__empty">Nenhum evento VISITA nesta data para consultar o clima.</div>`;
                return;
            }

            const sess = currentSession || getLoggedSession();
            const eventTarget = pickEventForWeather(visitaEvents, sess);
            const { origem, destino } = extractEventLocations(eventTarget || {}, sess);
            const locations = [];
            if (hasValidCoords(origem) || origem.label) locations.push({ ...origem, role:'Origem' });
            if (hasValidCoords(destino) || destino.label) locations.push({ ...destino, role:'Destino' });

            if (!locations.length) {
                dayWeatherMetaEl.textContent = 'Sem cidade definida';
                dayWeatherBodyEl.innerHTML = `<div class="day-weather__empty">N√£o encontramos cidade de origem/destino para consultar o clima.</div>`;
                return;
            }

            const dateLabel = selectedDate ? formatDateBr(selectedDate) : 'dia selecionado';
            dayWeatherMetaEl.textContent = `Previs√£o para ${dateLabel}`;
            dayWeatherBodyEl.innerHTML = `<div class="day-weather__empty">Buscando previs√£o para origem e destino...</div>`;

            const results = await Promise.all(locations.map(async (loc) => {
                try{
                    let resolved = { ...loc };
                    if (!hasValidCoords(resolved)) {
                        const geo = await geocodeCity(resolved.label);
                        if (geo) {
                            resolved = { ...resolved, lat: geo.lat, lon: geo.lon, label: resolved.label || geo.label };
                        }
                    }
                    if (!hasValidCoords(resolved)) throw new Error('Cidade n√£o encontrada');
                    const data = await fetchWeather(resolved.lat, resolved.lon);
                    return { loc: resolved, data };
                }catch(err){
                    return { loc, error: err };
                }
            }));

            if (token !== weatherRenderToken) return;

            dayWeatherBodyEl.innerHTML = results.map(res => {
                const loc = res.loc;
                if (res.error){
                    const errMsg = res.error && res.error.message ? res.error.message : 'Erro ao carregar clima';
                    return `<div class="day-weather__card"><h5><i class="fas fa-location-dot"></i> ${loc.role}</h5><div class="day-weather__empty">Erro ao carregar clima: ${errMsg}</div></div>`;
                }
                const temp = res.data.temperature != null ? `${res.data.temperature.toFixed(1)}¬∞C` : '‚Äî';
                const wind = res.data.wind != null ? `${res.data.wind.toFixed(1)} km/h` : '‚Äî';
                const precip = res.data.precipitation != null ? `${res.data.precipitation}%` : '‚Äî';
                const coordLabel = `${loc.lat.toFixed(2)}, ${loc.lon.toFixed(2)}`;
                const place = loc.label || coordLabel;
                return `
                    <div class="day-weather__card">
                        <h5><i class="fas fa-location-dot"></i> ${loc.role}${place ? ' ¬∑ ' + place : ''}</h5>
                        <div class="day-weather__metrics">
                            <span class="day-weather__metric"><i class="fas fa-temperature-half"></i> ${temp}</span>
                            <span class="day-weather__metric"><i class="fas fa-cloud"></i> ${res.data.description}</span>
                            <span class="day-weather__metric"><i class="fas fa-umbrella"></i> Chuva: ${precip}</span>
                            <span class="day-weather__metric"><i class="fas fa-wind"></i> Vento: ${wind}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function normalizePhone(phone){
            if (!phone) return null;
            const digits = String(phone).replace(/\D/g, '');
            if (digits.length < 8) return null;
            return digits;
        }

        function buildWhatsappLink(ev){
            const sess = getLoggedSession();
            const astronomerPhone = normalizePhone(sess?.telefone || sess?.celular || sess?.whatsapp || sess?.contato);
            const candidates = [
                ev.telefone_responsavel_evento,
                ev.telefone_responsavel,
                ev.telefone_do_responsavel,
                ev.responsavel_telefone,
                ev.responsavel_celular,
                ev.whatsapp_responsavel,
                ev.celular_responsavel,
                ev.contato_responsavel,
                ev.fone_responsavel,
                ev.responsavel_whatsapp,
                ev.telefone_evento,
                ev.telefone_escola,
                ev.telefone,
                ev.whatsapp,
                ev.celular,
                ev.contato,
                ev.fone,
                ev.phone,
                ev.phone_number
            ];
            for (const phone of candidates){
                const digits = normalizePhone(phone);
                if (!digits) continue;
                if (astronomerPhone && digits === astronomerPhone) continue;
                return `https://wa.me/${digits}`;
            }
            return null;
        }

        function buildRouteLink(ev){
            const oLat = toNumber(ev.origem_lat ?? ev.lat_origem ?? ev.latitude_origem);
            const oLon = toNumber(ev.origem_lon ?? ev.lon_origem ?? ev.longitude_origem);
            const dLat = toNumber(ev.destino_lat ?? ev.lat_destino ?? ev.latitude_destino);
            const dLon = toNumber(ev.destino_lon ?? ev.lon_destino ?? ev.longitude_destino);
            if (oLat === null || oLon === null || dLat === null || dLon === null) return null;
            return `https://www.google.com/maps/dir/?api=1&origin=${oLat},${oLon}&destination=${dLat},${dLon}`;
        }

        function buildSearchLinks(ev){
            const destCity = ev.cidade_destino || ev.cidade || ev.destino || ev.escola || '';
            const dLat = toNumber(ev.destino_lat ?? ev.lat_destino ?? ev.latitude_destino);
            const dLon = toNumber(ev.destino_lon ?? ev.lon_destino ?? ev.longitude_destino);
            const hasCoords = dLat !== null && dLon !== null;
            const baseHotels = hasCoords
                ? `https://www.google.com/maps/search/hotel/@${dLat},${dLon},14z`
                : `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent('hotel ' + destCity)}`;
            const baseFood = hasCoords
                ? `https://www.google.com/maps/search/restaurante/@${dLat},${dLon},14z`
                : `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent('restaurante ' + destCity)}`;
            return { hotels: baseHotels, food: baseFood };
        }

        function prettifyKey(key){
            return String(key || '')
                .replace(/^_+/, '')
                .replace(/_/g, ' ')
                .replace(/\b\w/g, m => m.toUpperCase());
        }

        // ==== Normaliza√ß√£o leve dos eventos ====
        function normalizeEvent(event, session){
            // Nome da escola
            const nome_escola =
                (event.nome_da_escola ||
                 event.nome_escola ||
                 event.escola ||
                 event.nome_lead ||
                 'Escola n√£o informada');

            const cidade =
                (event.cidade_destino ||
                 event.cidade ||
                 'Cidade n√£o informada');

            const tipo_da_tarefa =
                (event.tipo_da_tarefa ||
                 event.tipo_evento ||
                 event.tipo ||
                 event.id_tipo_tarefa ||
                 event.id_tipo ||
                 event.tipo_id ||
                 event.tipo_tarefa_id ||
                 'Evento');

            const dataObj = getEventDate(event);
            const taskMeta = resolveTaskType(event, session, tipo_da_tarefa);
            const eventId = getEventId(event);
            const diariasRaw = event.numero_de_diarias ?? event.diarias ?? event.qtd_diarias ?? event.numero_diarias ?? 1;
            const diariasNum = Math.max(1, parseInt(parseNum(diariasRaw), 10) || 1);
            const spanStart = dataObj instanceof Date ? dataObj : null;
            const spanEnd = spanStart ? new Date(spanStart.getFullYear(), spanStart.getMonth(), spanStart.getDate() + diariasNum - 1) : null;
            const color = colorForEvent(eventId);

            return {
                ...event,
                _id: eventId,
                _date: dataObj,
                _taskType: taskMeta.type,
                _taskTypeId: taskMeta.id,
                nome_da_escola: nome_escola,
                cidade: cidade,
                tipo_da_tarefa: tipo_da_tarefa,
                _spanStart: spanStart,
                _spanEnd: spanEnd,
                _color: color
            };
        }

        function getEventId(ev){
            return ev._id || ev.id_evento || ev.id_evento_unico || ev.id || ev.id_agendamento || ev.uuid || String(Math.random()).slice(2);
        }

        function isDateInEventSpan(date, ev){
            if (!(date instanceof Date) || Number.isNaN(date.getTime())) return false;
            const start = ev._spanStart || ev._date;
            const end = ev._spanEnd || ev._date;
            if (!(start instanceof Date) || Number.isNaN(start.getTime())) return false;
            const endDate = (end instanceof Date && !Number.isNaN(end.getTime())) ? end : start;
            const target = startOfDay(date);
            const startDay = startOfDay(start);
            const endDay = startOfDay(endDate);
            return target >= startDay && target <= endDay;
        }

        function buildEventsByDay(list){
            const map = new Map();
            if (!Array.isArray(list)) return map;
            list.forEach(ev => {
                const start = ev._spanStart || ev._date;
                const end = ev._spanEnd || ev._date;
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                const endDate = (end instanceof Date && !Number.isNaN(end.getTime())) ? end : start;
                const cursor = new Date(start.getFullYear(), start.getMonth(), start.getDate());
                while (cursor <= endDate) {
                    const k = dateKey(cursor);
                    if (k) {
                        if (!map.has(k)) map.set(k, []);
                        map.get(k).push(ev);
                    }
                    cursor.setDate(cursor.getDate() + 1);
                }
            });
            return map;
        }

        function uniqueEventsById(arr){
            if (!Array.isArray(arr)) return [];
            const seen = new Set();
            return arr.filter(ev => {
                const id = getEventId(ev);
                if (seen.has(id)) return false;
                seen.add(id);
                return true;
            });
        }

        function getEventIdCandidates(ev){
            if (!ev || typeof ev !== 'object') return [];
            const ids = [
                ev.id_evento,
                ev.id_evento_unico,
                ev.id_agendamento,
                ev.id,
                ev.uuid,
                ev.evento_id
            ].filter(v => v !== undefined && v !== null && v !== '');
            if (!ids.length && ev._id) ids.push(ev._id);
            return ids.map(v => String(v));
        }

        function scoreEventForMerge(ev){
            if (!ev || typeof ev !== 'object') return 0;
            let score = 0;
            if (ev.id_evento != null) score += 6;
            if (ev.id_evento_unico != null) score += 5;
            if (ev.id_agendamento != null) score += 4;
            if (ev.id != null) score += 3;
            if (ev.uuid) score += 2;
            if (ev.data_e_hora_agendamento || ev.data_e_hora_do_agendamento || ev.data_agendamento || ev.data) score += 2;
            if (ev.nome_da_escola || ev.nome_escola || ev.escola || ev.nome_lead) score += 2;
            if (ev.cidade || ev.cidade_destino) score += 1;
            if (ev.conteudo_da_apresentacao || ev.conteudo_apresentacao || ev.conteudo || ev.apresentacao) score += 1;
            const lat = toNumber(ev.destino_lat ?? ev.lat_destino ?? ev.latitude_destino);
            const lon = toNumber(ev.destino_lon ?? ev.lon_destino ?? ev.longitude_destino);
            if (lat !== null && lon !== null) score += 1;
            if (ev.finalizado === true || ev.finalizado === 'true') score += 1;
            return score;
        }

        function mergeDuplicateEvents(base, incoming){
            if (!base) return incoming;
            if (!incoming) return base;
            const incomingWins = scoreEventForMerge(incoming) > scoreEventForMerge(base);
            const primary = incomingWins ? incoming : base;
            const secondary = incomingWins ? base : incoming;
            const merged = { ...primary };
            Object.entries(secondary).forEach(([k,v]) => {
                if (merged[k] === undefined || merged[k] === null || merged[k] === '' || merged[k] === 'null') {
                    merged[k] = v;
                }
            });
            const ids = new Set([...getEventIdCandidates(base), ...getEventIdCandidates(incoming)]);
            if (ids.size > 1) merged._duplicate_ids = Array.from(ids);
            return merged;
        }

        function dedupeEventsBySignature(arr){
            if (!Array.isArray(arr)) return [];
            const sigMap = new Map();
            const result = [];
            arr.forEach(ev => {
                const sig = canonicalEventSignature(ev);
                if (!sig) {
                    result.push(ev);
                    return;
                }
                if (sigMap.has(sig)) {
                    const merged = mergeDuplicateEvents(sigMap.get(sig), ev);
                    const idx = result.indexOf(sigMap.get(sig));
                    if (idx >= 0) result[idx] = merged;
                    sigMap.set(sig, merged);
                } else {
                    sigMap.set(sig, ev);
                    result.push(ev);
                }
            });
            return result;
        }

        function eventGroupKey(ev){
            if (!ev || typeof ev !== 'object') return '';
            const escola = (ev.nome_da_escola || ev.nome_escola || ev.escola || '').toString().trim().toLowerCase();
            const cidade = normalizeCityUF(ev.cidade || ev.cidade_destino || '').toString().trim().toLowerCase();
            const conteudo = (ev.conteudo_da_apresentacao || ev.conteudo_apresentacao || ev.conteudo || ev.apresentacao || '').toString().trim().toLowerCase();
            const tipo = (ev._taskType || ev.tipo_da_tarefa || ev.tipo_evento || ev.tipo || '').toString().trim().toLowerCase();
            const idTipo = ev.id_tipo_tarefa ?? ev.id_tipo ?? ev.id_tipo_evento ?? ev.id_tipo_da_tarefa ?? ev.tipo_tarefa_id ?? '';
            const astroId = ev.id_astronomo ?? ev.astronomo_id ?? ev.astronomoId ?? '';
            return JSON.stringify({ escola, cidade, conteudo, tipo, idTipo: String(idTipo), astroId: String(astroId) });
        }

        function collapseConsecutiveEventSpans(list){
            if (!Array.isArray(list)) return [];
            const grouped = new Map();
            const passthrough = [];
            list.forEach(ev => {
                const key = eventGroupKey(ev);
                if (!key) {
                    passthrough.push(ev);
                    return;
                }
                const start = ev._spanStart || ev._date || getEventDate(ev);
                const end = ev._spanEnd || start;
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                const endDate = (end instanceof Date && !Number.isNaN(end.getTime())) ? end : start;
                const item = {
                    ev,
                    start: startOfDay(start),
                    end: startOfDay(endDate)
                };
                if (!grouped.has(key)) grouped.set(key, []);
                grouped.get(key).push(item);
            });

            const result = [];
            grouped.forEach(items => {
                items.sort((a, b) => a.start - b.start);
                let current = null;
                items.forEach(item => {
                    if (!current) {
                        current = { ...item };
                        return;
                    }
                    const nextStart = item.start;
                    const currEnd = current.end;
                    const mergeLimit = new Date(currEnd.getFullYear(), currEnd.getMonth(), currEnd.getDate() + 1);
                    if (nextStart <= mergeLimit) {
                        current.end = item.end > current.end ? item.end : current.end;
                        current.ev = mergeDuplicateEvents(current.ev, item.ev);
                    } else {
                        result.push(current);
                        current = { ...item };
                    }
                });
                if (current) result.push(current);
            });

            const collapsed = result.map(item => {
                const merged = { ...item.ev };
                merged._spanStart = item.start;
                merged._spanEnd = item.end;
                merged._date = item.start;
                return merged;
            });
            return collapsed.concat(passthrough);
        }

        function dedupeEventsById(list){
            const base = uniqueEventsById(Array.isArray(list) ? list : []);
            const bySignature = dedupeEventsBySignature(base);
            return collapseConsecutiveEventSpans(bySignature);
        }

        function isVisitaEvent(ev){
            const t = (ev && (ev._taskType || ev.tipo_da_tarefa || ev.tipo_evento || ev.tipo || '')).toString().toLowerCase();
            return t.includes('visita');
        }

        async function lancarDespesas(ev, btn){
            const id = getEventId(ev);
            if (!id) return;
            // Salva o evento selecionado para ser usado no formul√°rio real em despesas.html
            try{
                localStorage.setItem('despesas_evento_selecionado', JSON.stringify(ev));
            }catch(_){}
            window.location.href = 'despesas.html';
        }

        function removeEventById(id){
            if (!id) return;
            const idStr = String(id);
            eventsDataRaw = eventsDataRaw.filter(ev => String(getEventId(ev)) !== idStr);
            eventsData = dedupeEventsById(eventsDataRaw);
        }

        async function finalizarEvento(ev, btn){
            const id = getEventId(ev);
            if (!id) return;
            if (btn){
                btn.disabled = true;
                btn.dataset.prevLabel = btn.innerHTML;
                btn.innerHTML = 'Finalizando...';
            }
            try{
                const payload = { action:'finalizar_evento', id_evento:id, finalizado:true };
                const resp = await fetch(API_AGENDA, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify(payload)
                });
                const txt = await resp.text().catch(()=> '');
                if (!resp.ok) throw new Error(txt || `HTTP ${resp.status}`);
                removeEventById(id);
                renderCalendar();
                renderEventsList();
                renderDayEventsDetails();
                alert('Evento finalizado e removido da lista.');
            }catch(err){
                console.error('Erro ao finalizar evento:', err);
                alert('Erro ao finalizar evento: ' + (err && err.message));
            }finally{
                if (btn){
                    btn.disabled = false;
                    btn.innerHTML = btn.dataset.prevLabel || '‚úÖ Finalizar';
                }
            }
        }

        async function deletarEvento(ev, btn){
            const id = getEventId(ev);
            if (!id) return;
            if (!window.confirm('Deseja realmente deletar este evento?')) return;
            if (btn){
                btn.disabled = true;
                btn.dataset.prevLabel = btn.innerHTML;
                btn.innerHTML = 'Deletando...';
            }
            try{
                const payload = { action:'delete_evento', id_evento:id };
                const resp = await fetch(API_AGENDA, {
                    method:'POST',
                    headers:{'Content-Type':'application/json'},
                    body: JSON.stringify(payload)
                });
                const txt = await resp.text().catch(()=> '');
                if (!resp.ok) throw new Error(txt || `HTTP ${resp.status}`);
                removeEventById(id);
                renderCalendar();
                renderEventsList();
                renderDayEventsDetails();
                alert('Evento deletado com sucesso.');
                closeEventModal();
            }catch(err){
                console.error('Erro ao deletar evento:', err);
                alert('Erro ao deletar evento: ' + (err && err.message));
            }finally{
                if (btn){
                    btn.disabled = false;
                    btn.innerHTML = btn.dataset.prevLabel || 'üóëÔ∏è Deletar';
                }
            }
        }

        function canonicalEventSignature(ev){
            if (!ev || typeof ev !== 'object') return '';
            const baseDate = ev._date || getEventDate(ev);
            const dateStr = baseDate ? dateKey(baseDate) : '';
            const horarioRaw = ev.data_e_hora_agendamento || ev.data_e_hora_do_agendamento || ev.data_agendamento || ev.data;
            const horario = horarioRaw ? new Date(horarioRaw) : null;
            const horaStr = horario instanceof Date && !Number.isNaN(horario.getTime()) ? horario.toISOString() : '';
            const escola = (ev.nome_da_escola || ev.nome_escola || ev.escola || '').toString().trim().toLowerCase();
            const cidade = normalizeCityUF(ev.cidade || ev.cidade_destino || '').toLowerCase();
            const conteudo = (ev.conteudo_da_apresentacao || ev.conteudo_apresentacao || ev.conteudo || ev.apresentacao || '').toString().trim().toLowerCase();
            const tipo = (ev._taskType || ev.tipo_da_tarefa || ev.tipo_evento || ev.tipo || '').toString().trim().toLowerCase();
            return JSON.stringify({ dateStr, horaStr, escola, cidade, conteudo, tipo });
        }

        function getDiariasCount(ev){
            if (!ev) return 1;
            const start = ev._spanStart || ev._date;
            const end = ev._spanEnd || ev._date;
            if (!(start instanceof Date) || Number.isNaN(start)) return 1;
            if (!(end instanceof Date) || Number.isNaN(end)) return 1;
            const diff = Math.round((end.getTime() - start.getTime()) / 86400000) + 1;
            return Math.max(1, diff);
        }

        function getEffectiveEvents(){
            return showDuplicates ? eventsDataRaw : eventsData;
        }

        function toggleDuplicateView(force){
            if (typeof force === 'boolean') showDuplicates = force;
            else showDuplicates = !showDuplicates;
            renderCalendar();
            renderEventsList();
            renderDayEventsDetails();
        }

        function showDuplicatePopup(ignoredCount){
            if (!ignoredCount) return;
            if (!window.AstroPopup || typeof window.AstroPopup.show !== 'function') return;
            const actionLabel = showDuplicates ? 'Ocultar eventos duplicados' : 'Ver eventos duplicados';
            window.AstroPopup.show(
                'Eventos duplicados id√™nticos foram ignorados. Se quiser ver mais, clique em Ver eventos duplicados.',
                'info',
                0,
                {
                    actionLabel,
                    closeOnAction: false,
                    onAction: (btn) => {
                        toggleDuplicateView();
                        if (btn) btn.textContent = showDuplicates ? 'Ocultar eventos duplicados' : 'Ver eventos duplicados';
                    }
                }
            );
        }

        // ==== Filtro por tipo de tarefa ====
        function getFilteredEvents(){
            const base = getEffectiveEvents();
            if (!Array.isArray(base) || base.length === 0) return [];
            if (!currentTaskFilter || currentTaskFilter.type === 'all') return base;
            const sameType = ev => ev._taskType === currentTaskFilter.type;
            const byType = base.filter(sameType);
            if (!currentTaskFilter.id) return byType;

            const byId = byType.filter(ev => String(ev._taskTypeId || '') === String(currentTaskFilter.id));
            if (byId.length) return byId;

            // Fallback: se o ID n√£o bateu (ou veio vazio do backend), mantemos apenas o tipo
            console.warn('Filtro por ID de tarefa n√£o encontrou eventos; aplicando somente o tipo.', currentTaskFilter);
            return byType;
        }

        // ==== Render do calend√°rio ====
        function renderCalendar(){
            if (!currentMonthDate) currentMonthDate = new Date();
            // Garante que est√° no dia 1 do m√™s
            currentMonthDate = new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth(), 1);
            saveIndexUIState();

            currentMonthLabel.textContent = formatMonthYearBr(currentMonthDate);

            const year = currentMonthDate.getFullYear();
            const month = currentMonthDate.getMonth();

            const firstDayOfWeek = new Date(year, month, 1).getDay(); // 0=Dom
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            const filtered = getFilteredEvents();
            const eventsByDay = buildEventsByDay(filtered);

            let html = '';
            let dayOfWeekCounter = 0;

            html += '<tr>';
            // C√©lulas vazias antes do dia 1
            for (let i = 0; i < firstDayOfWeek; i++) {
                html += '<td class="calendar-day empty"></td>';
                dayOfWeekCounter++;
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const cellDate = new Date(year, month, day);
                const cellKey = dateKey(cellDate);

                const eventsForDayRaw = eventsByDay.get(cellKey) || [];
                const eventsForDay = uniqueEventsById(eventsForDayRaw);
                const hasEvents = eventsForDay.length > 0;

                const isSelected = selectedDate && sameDay(selectedDate, cellDate);
                const mainColor = hasEvents ? (eventsForDay[0]?._color || null) : null;
                const dayStyle = mainColor ? `style="--day-color:${mainColor}"` : '';
                const chips = hasEvents
                    ? eventsForDay.slice(0,4).map((ev) => {
                        const diarias = getDiariasCount(ev);
                        const title = ev.nome_da_escola || ev.cidade || 'Evento';
                        return `<span class="day-event-chip" style="--ev-color:${ev._color || '#7b5cff'}" title="${title}">${diarias}</span>`;
                    }).join('') + (eventsForDay.length > 4 ? `<span class="day-event-chip more">+${eventsForDay.length - 4}</span>` : '')
                    : '';

                html += `
                    <td class="calendar-day ${hasEvents ? 'has-events' : ''} ${isSelected ? 'selected' : ''}"
                        data-date="${cellKey}" ${dayStyle}>
                        <div class="day-number">${day}</div>
                        ${hasEvents ? `<div class="day-event-chip-container">${chips}</div>` : ''}
                    </td>
                `;

                dayOfWeekCounter++;
                if (dayOfWeekCounter === 7 && day < daysInMonth) {
                    html += '</tr><tr>';
                    dayOfWeekCounter = 0;
                }
            }

            // completa a √∫ltima linha com vazios se necess√°rio
            if (dayOfWeekCounter > 0 && dayOfWeekCounter < 7) {
                for (let i = dayOfWeekCounter; i < 7; i++) {
                    html += '<td class="calendar-day empty"></td>';
                }
                html += '</tr>';
            } else {
                html += '</tr>';
            }

            calendarBody.innerHTML = html;

            // Listeners para clicar nos dias
            Array.from(calendarBody.querySelectorAll('.calendar-day'))
                .forEach(td => {
                    if (td.classList.contains('empty')) return;
                    td.addEventListener('click', () => {
                        const iso = td.dataset.date;
                        const d = parseDateKey(iso);
                        if (d && !Number.isNaN(d.getTime())) {
                            selectedDate = d;
                            saveIndexUIState();
                            renderCalendar();  // re-render para aplicar classe selected
                            renderDayEventsDetails(); // mostra eventos do dia abaixo do calend√°rio
                        }
                    });
                });
        }

        // ==== Lista de eventos do dia selecionado ====
        function renderDayEventsDetails(){
            if (!dayDetailBody || !dayDetailLabel || !dayDetailCount) return;

            if (!selectedDate) {
                const today = startOfDay(new Date());
                selectedDate = today;
            }

            const baseList = getFilteredEvents();
            const dayEvents = uniqueEventsById(baseList.filter(ev => isDateInEventSpan(selectedDate, ev)));

            dayDetailLabel.textContent = formatDateBr(selectedDate);
            dayDetailCount.textContent = `${dayEvents.length} evento(s)`;
            saveIndexUIState();

            if (!dayEvents.length) {
                dayDetailBody.innerHTML = `<div class="day-detail__empty">Clique em um dia do calend√°rio para ver os eventos dessa data.</div>`;
                renderWeatherForSelection([]);
                return;
            }

            let html = '';
            dayEvents.forEach((ev, idx) => {
                const escola = ev.nome_da_escola || 'Escola n√£o informada';
                const cidade = formatOrigemDestino(ev);
                const conteudo = ev.conteudo_da_apresentacao || ev.conteudo_apresentacao || ev.conteudo || ev.apresentacao || '‚Äî';
                const valor = formatCurrencyBR(ev.valor_total ?? ev.total ?? ev.valor ?? ev.custo_total);
                const distancia = getDistanceLabel(ev);
                    const duracao = getDurationLabel(ev);
                html += `
                    <div class="day-detail__card" data-day-ev="${idx}">
                        <h4><span style="color:${ev._color || '#7b5cff'};">‚óè</span> ${escola}</h4>
                        <div class="day-detail__meta">
                            <span><i class="fas fa-location-dot"></i> ${cidade || 'Cidade n√£o informada'}</span>
                            <span><i class="fas fa-calendar-day"></i> ${formatDateBr(ev._date || selectedDate)}</span>
                        </div>
                        <div class="day-detail__chips">
                            <span class="day-detail__chip"><i class="fas fa-meteor"></i> ${conteudo}</span>
                            <span class="day-detail__chip"><i class="fas fa-route"></i> ${distancia}</span>
                            <span class="day-detail__chip"><i class="fas fa-coins"></i> ${valor}</span>
                            ${duracao ? `<span class="day-detail__chip"><i class="fas fa-hourglass-half"></i> ${duracao}</span>` : ''}
                            <span class="day-detail__chip"><i class="fas fa-flag"></i> ${formatTaskLabel(ev._taskType)}</span>
                            <span class="day-detail__chip"><i class="fas fa-clipboard-check"></i> Resultado: ${getResultadoLabel(ev)}</span>
                        </div>
                    </div>
                `;
            });

            dayDetailBody.innerHTML = html;
            const cards = Array.from(dayDetailBody.querySelectorAll('[data-day-ev]'));
            cards.forEach(card => {
                const idx = Number(card.dataset.dayEv);
                const ev = dayEvents[idx];
                if (!ev) return;
                card.addEventListener('click', () => openEventModal(ev));
            });

            renderWeatherForSelection(dayEvents);
        }

        // ==== Imagens do evento (carrossel) ====
        async function fetchEventImages(eventId, extraPayload){
            const formData = new FormData();
            formData.append('action', 'get_img');
            if (eventId) {
                formData.append('id_evento', eventId);
                formData.append('id_evento_unico', eventId);
            }
            const row = extraPayload && (extraPayload.row_number ?? extraPayload.row ?? extraPayload.row_num);
            if (row != null) formData.append('row_number', String(row));
            if (extraPayload && extraPayload.school) formData.append('nome_da_escola', extraPayload.school);

            const response = await fetch(API_EVENT_IMAGES, { method:'POST', body: formData });
            const bodyText = await response.text().catch(() => '');
            if (!response.ok) throw new Error(bodyText || 'Erro ao buscar imagens');

            let entries = [];
            try {
                const data = bodyText ? JSON.parse(bodyText) : null;
                if (Array.isArray(data) && data.length && typeof data[0] === 'object' && ('img' in data[0])) {
                    entries = data
                        .map(item => {
                            if (!item || typeof item.img !== 'string') return null;
                            const url = item.img.trim();
                            if (!url || !url.startsWith('http')) return null;
                            const name = (item.name || '').toString().trim();
                            const rowNum = item.row_number != null ? Number(item.row_number) : null;
                            return { url, name, row: rowNum };
                        })
                        .filter(Boolean);
                } else if (data && Array.isArray(data.links)) {
                    entries = data.links
                        .map(link => {
                            const url = String(link || '').trim();
                            return url && url.startsWith('http') ? { url, name: '', row: null } : null;
                        })
                        .filter(Boolean);
                } else if (data && Array.isArray(data.data)) {
                    entries = data.data
                        .map(link => {
                            const url = String(link || '').trim();
                            return url && url.startsWith('http') ? { url, name: '', row: null } : null;
                        })
                        .filter(Boolean);
                } else if (data && typeof data === 'object') {
                    Object.values(data).forEach(v => {
                        if (typeof v === 'string' && v.startsWith('http')) {
                            entries.push({ url: v, name: '', row: null });
                        } else if (Array.isArray(v)) {
                            v.forEach(inner => {
                                if (typeof inner === 'string' && inner.startsWith('http')) {
                                    entries.push({ url: inner, name: '', row: null });
                                }
                            });
                        }
                    });
                }
            } catch (_) {
                const regex = /(https?:\/\/[^\s"']+)/g;
                let match;
                while ((match = regex.exec(bodyText)) !== null) {
                    const url = match[1];
                    if (url && url.startsWith('http')) entries.push({ url, name: '', row: null });
                }
            }

            const seen = new Set();
            return entries.filter(entry => {
                const key = entry && entry.url ? String(entry.url) : '';
                if (!key || seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        }

        function renderImageCarousel(container, entries){
            if (!container) return;
            if (!Array.isArray(entries) || !entries.length) {
                container.innerHTML = `<div class="event-images-placeholder">Nenhuma imagem encontrada para este evento.</div>`;
                return;
            }

            let idx = 0;
            container.innerHTML = `
                <div class="img-carousel">
                    <button class="img-carousel-nav" data-dir="-1" aria-label="Imagem anterior">‚Äπ</button>
                    <div class="img-carousel-frame">
                        <img data-carousel-img src="" alt="Imagem do evento" loading="lazy" decoding="async" referrerpolicy="no-referrer">
                    </div>
                    <button class="img-carousel-nav" data-dir="1" aria-label="Pr√≥xima imagem">‚Ä∫</button>
                </div>
                <div class="img-carousel-meta">
                    <span data-carousel-counter></span>
                    <a data-carousel-link href="#" target="_blank" rel="noopener noreferrer">Abrir imagem</a>
                </div>
            `;

            const imgEl = container.querySelector('[data-carousel-img]');
            const counterEl = container.querySelector('[data-carousel-counter]');
            const linkEl = container.querySelector('[data-carousel-link]');
            const navButtons = Array.from(container.querySelectorAll('.img-carousel-nav'));
            navButtons.forEach(btn => { btn.disabled = entries.length <= 1; });

            const update = () => {
                const item = entries[idx];
                if (!item) return;
                imgEl.src = item.url;
                imgEl.alt = item.name || 'Imagem do evento';
                counterEl.textContent = `${idx + 1} / ${entries.length}`;
                linkEl.href = item.url;
                linkEl.textContent = item.name ? `Abrir ${item.name}` : 'Abrir imagem em nova aba';
            };

            navButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const dir = Number(btn.dataset.dir) || 1;
                    idx = (idx + dir + entries.length) % entries.length;
                    update();
                });
            });

            update();
        }

        function setLightboxImages(entries){
            lightboxImages = Array.isArray(entries) ? entries.filter(e => e && e.url) : [];
            lightboxIndex = 0;
            updateImageLightbox();
        }

        function updateImageLightbox(){
            if (!lightboxEl || !lightboxImg || !lightboxCounter) return;
            if (!lightboxImages.length) {
                lightboxEl.classList.remove('show');
                lightboxEl.setAttribute('aria-hidden','true');
                return;
            }
            const cur = lightboxImages[lightboxIndex];
            lightboxImg.src = cur.url;
            lightboxImg.alt = cur.name || 'Imagem do evento';
            lightboxCounter.textContent = `${lightboxIndex + 1} / ${lightboxImages.length}`;
        }

        function openImageLightbox(idx = 0){
            if (!lightboxImages.length || !lightboxEl) return;
            lightboxIndex = Math.max(0, Math.min(idx, lightboxImages.length - 1));
            updateImageLightbox();
            lightboxEl.classList.add('show');
            lightboxEl.setAttribute('aria-hidden','false');
        }

        function closeImageLightbox(){
            if (!lightboxEl) return;
            lightboxEl.classList.remove('show');
            lightboxEl.setAttribute('aria-hidden','true');
        }

        function nextLightboxImage(){
            if (!lightboxImages.length) return;
            lightboxIndex = (lightboxIndex + 1) % lightboxImages.length;
            updateImageLightbox();
        }

        function prevLightboxImage(){
            if (!lightboxImages.length) return;
            lightboxIndex = (lightboxIndex - 1 + lightboxImages.length) % lightboxImages.length;
            updateImageLightbox();
        }

        async function loadEventImagesIntoContainer(eventId, container, triggerBtn, extraPayload){
            if (!container || !eventId) return;
            container.innerHTML = `<div class="event-images-placeholder">Carregando imagens...</div>`;
            if (triggerBtn) {
                triggerBtn.disabled = true;
                triggerBtn.dataset.prevLabel = triggerBtn.innerHTML;
                triggerBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Carregando';
            }
            try {
                const entries = await fetchEventImages(eventId, extraPayload);
                if (Array.isArray(entries) && entries.length) {
                    container.innerHTML = `
                        <div class="event-images-placeholder">
                            ${entries.length} imagem(ns) encontrada(s). Clique em "Ver imagens" para abrir em tela cheia.
                        </div>
                    `;
                    setLightboxImages(entries);
                    openImageLightbox(0);
                    if (triggerBtn) {
                        triggerBtn.innerHTML = '<i class="fas fa-image"></i> Abrir em tela cheia';
                        triggerBtn.disabled = false;
                        triggerBtn.onclick = () => openImageLightbox(0);
                    }
                } else {
                    container.innerHTML = `<div class="event-images-placeholder">Nenhuma imagem encontrada para este evento.</div>`;
                }
            } catch (err) {
                console.error('Erro ao carregar imagens do evento:', err);
                container.innerHTML = `<div class="event-images-placeholder">Erro ao carregar imagens. Tente novamente.</div>`;
            } finally {
                if (triggerBtn) {
                    triggerBtn.disabled = false;
                    triggerBtn.innerHTML = triggerBtn.dataset.prevLabel || '<i class="fas fa-image"></i> Ver imagens';
                }
            }
        }

        // ==== Modal de detalhes ====
        function closeEventModal(){
            if (eventModal) {
                eventModal.classList.remove('show');
                eventModal.setAttribute('aria-hidden', 'true');
            }
        }

        // ==== Modal de detalhes OTIMIZADO ====
        function openEventModal(ev) {
            if (!ev || !eventModalBody) return;

            const eventId = getEventId(ev);

            // 1. Defini√ß√£o de dados principais
            const titleLabel = ev.nome_da_escola || ev.cidade || (ev.tipo_da_tarefa || 'Evento Detalhado');
            const responsavel = ev.responsavel || ev.responsavel_visita || ev.contato_responsavel || ev.nome_responsavel || '';
            const cidade = normalizeCityUF(ev.cidade_destino || ev.cidade || '');
            const dataFormatada = ev._date ? formatDateBr(ev._date) : 'Data a definir';

            // Links e A√ß√µes
            const whatsappLink = buildWhatsappLink(ev);
            const routeLink = buildRouteLink(ev);
            const searchLinks = buildSearchLinks(ev);

            // Bot√µes de a√ß√£o principais
            const despesasBtn = `<button class="btn btn-secondary btn-compact" data-ev-action="despesas" data-ev-id="${eventId}">üí∞ Despesas</button>`;
            const finalizarBtn = `<button class="btn btn-secondary btn-compact" data-ev-action="finalizar" data-ev-id="${eventId}">‚úÖ Finalizar</button>`;
            const deletarBtn = `<button class="btn btn-danger btn-compact" data-ev-action="deletar" data-ev-id="${eventId}">üóëÔ∏è Deletar</button>`;

            // 2. Constru√ß√£o dos "Quick Chips" (Apenas info relevante)
            let chipsHtml = '';

            // Valor (se existir)
            const valor = ev.valor_total ?? ev.total ?? ev.valor ?? ev.custo_total;
            if (valor) chipsHtml += `<span class="event-chip"><i class="fas fa-coins"></i> <strong>Valor:</strong> ${formatCurrencyBR(valor)}</span>`;

            // Dist√¢ncia (se existir)
            const dist = getDistanceLabel(ev);
            if (dist && dist !== '‚Äî') chipsHtml += `<span class="event-chip"><i class="fas fa-route"></i> ${dist}</span>`;

            // Resultado (apenas se preenchido)
            const resultado = getResultadoLabel(ev);
            if (resultado && resultado !== 'Resultado n√£o informado') {
                chipsHtml += `<span class="event-chip"><i class="fas fa-clipboard-check"></i> ${resultado}</span>`;
            }

            // Rota Cont√≠nua (APENAS se for true)
            if (ev.rota_continua === true || ev.rota_continua === 'true' || ev.rota_continua === 1) {
                chipsHtml += `<span class="event-chip" style="border-color:var(--neon-purple); color:var(--neon-purple);"><i class="fas fa-infinity"></i> Rota Cont√≠nua</span>`;
            }

            // 3. Renderiza√ß√£o Din√¢mica dos Detalhes (Filtrando lixo)
            const excludeKeys = new Set([
                'id', '_id', '_date', '_color', '_spanStart', '_spanEnd', '_taskType', '_taskTypeId',
                'tasktypeid', 'spanstart', 'spanend', 'color',
                'rota_continua', 'rotacontinua', 'rota', 'continua', 'blocoindex',
                'rota_idx', '_rota_idx', 'rota_total', '_rota_total',
                'dist_override_km', '_dist_override_km',
                'createdat', 'created_at', 'updatedat', 'updated_at',
                'origem_lat', 'origem_lon', 'destino_lat', 'destino_lon',
                'lat_origem', 'lon_origem', 'lat_destino', 'lon_destino',
                'latitude_origem', 'longitude_origem', 'latitude_destino', 'longitude_destino',
                'nome_da_escola', 'cidade_destino', 'cidade', 'responsavel'
            ]);

            let detailsHtml = '';

            // Adiciona Observa√ß√µes primeiro se existir (campo importante)
            const obs = ev.informacoes_adicionais || ev.observacoes || ev.observacao || ev.obs;
            if (obs) {
                detailsHtml += `
                    <div class="event-detail-box" style="grid-column: 1/-1;">
                        <span class="event-detail-label">Observa√ß√µes</span>
                        <span class="event-detail-value" style="white-space: pre-wrap;">${obs}</span>
                    </div>`;
            }

            // Loop inteligente
            Object.entries(ev).forEach(([key, val]) => {
                const normalizedKey = key.toLowerCase().replace(/[^a-z0-9]/g, '');

                // Filtros de exclus√£o
                if (excludeKeys.has(key) || excludeKeys.has(normalizedKey)) return;
                if (val === null || val === undefined || val === '' || val === 'null') return;
                if ((typeof val === 'string') && val.trim() === '') return;

                // Filtro espec√≠fico: Se for booleano false, n√£o mostra
                if (val === false || val === 'false') return;

                // Formata√ß√£o da Chave (ex: numero_de_alunos -> N√∫mero de Alunos)
                let label = key.replace(/_/g, ' ').replace(/([A-Z])/g, ' $1').trim();
                label = label.charAt(0).toUpperCase() + label.slice(1);

                // Formata√ß√£o do Valor
                let displayVal = val;
                if (typeof val === 'object') displayVal = JSON.stringify(val);
                if (val === true || val === 'true') displayVal = 'Sim';

                detailsHtml += `
                    <div class="event-detail-box">
                        <span class="event-detail-label">${label}</span>
                        <span class="event-detail-value">${displayVal}</span>
                    </div>
                `;
            });

            // 4. Montagem dos Bot√µes de Links
            let linksHtml = '';
            if (whatsappLink) linksHtml += `<a href="${whatsappLink}" target="_blank" class="modal-btn-link"><i class="fab fa-whatsapp"></i> WhatsApp</a>`;
            if (routeLink) linksHtml += `<a href="${routeLink}" target="_blank" class="modal-btn-link"><i class="fas fa-location-arrow"></i> Rota GPS</a>`;
            if (searchLinks?.hotels) linksHtml += `<a href="${searchLinks.hotels}" target="_blank" class="modal-btn-link"><i class="fas fa-bed"></i> Hot√©is</a>`;

            // 5. HTML Final do Modal
            eventModalBody.innerHTML = `
                <div class="event-modal-header">
                    <h3 class="event-modal-title">${titleLabel}</h3>
                    <div class="event-modal-subtitle">
                        <span><i class="fas fa-calendar-day"></i> ${dataFormatada}</span>
                        ${cidade ? `<span><i class="fas fa-map-marker-alt"></i> ${cidade}</span>` : ''}
                        ${responsavel ? `<span><i class="fas fa-user"></i> ${responsavel}</span>` : ''}
                    </div>
                </div>

                <div class="event-modal-quick">
                    ${chipsHtml}
                </div>

                <div class="event-details-grid">
                    ${detailsHtml}
                </div>

                <div class="event-modal-actions">
                    ${linksHtml}
                </div>

                <div class="event-modal-actions" style="border:none; padding-top:0; margin-top:10px; justify-content: flex-end;">
                    ${despesasBtn}
                    ${finalizarBtn}
                    ${deletarBtn}
                </div>

                <!-- Se√ß√£o de Imagens (mantida da original, apenas container limpo) -->
                <div id="modal-images-container" style="margin-top: 24px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 16px;">
                     <div class="event-images-header">
                        <h4 style="font-size: 0.9rem; color: #94a3b8; margin-bottom:10px;">Galeria</h4>
                        <button class="event-images-btn" data-event-id="${eventId || ''}">
                            <i class="fas fa-image"></i> Carregar Imagens
                        </button>
                    </div>
                    <div class="event-images-body" id="event-images-body" style="background:transparent; border:none; padding:0;"></div>
                </div>
            `;

            eventModal.classList.add('show');
            eventModal.setAttribute('aria-hidden', 'false');

            // Reattach listeners para imagens e a√ß√µes
            const imagesBody = eventModalBody.querySelector('#event-images-body');
            const imagesBtn = eventModalBody.querySelector('.event-images-btn');
            if (imagesBtn && imagesBody && eventId) {
                imagesBtn.addEventListener('click', () => {
                    loadEventImagesIntoContainer(eventId, imagesBody, imagesBtn, {
                        row_number: ev.row_number,
                        school: ev.nome_da_escola
                    });
                });
            }

            eventModalBody.querySelectorAll('[data-ev-action]').forEach(btn => {
                const action = btn.dataset.evAction;
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (action === 'despesas') lancarDespesas(ev, btn);
                    else if (action === 'finalizar') finalizarEvento(ev, btn);
                    else if (action === 'deletar') deletarEvento(ev, btn);
                });
            });
        }

        function formatInfoTitle(text){
            return text
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/\n/g, '&#10;');
        }

        // ==== Render da lista de eventos ====
        function renderEventsList(){
            const filtered = getFilteredEvents();
            let list = filtered.slice();

            // Ordena por data crescente; eventos sem data v√£o para o final (pendentes)
            list.sort((a, b) => {
                const da = a._date ? a._date.getTime() : Number.POSITIVE_INFINITY;
                const db = b._date ? b._date.getTime() : Number.POSITIVE_INFINITY;
                return da - db;
            });

            eventsCountEl.textContent = `${list.length} evento(s)`;

            if (list.length === 0) {
                eventsListEl.innerHTML = `
                    <div class="empty-state">
                        Nenhum evento encontrado com o filtro atual.
                    </div>
                `;
                return;
            }

            // Helpers para separar visitas antes/depois de hoje
            const startOfToday = (() => {
                const t = new Date();
                return new Date(t.getFullYear(), t.getMonth(), t.getDate());
            })();
            const isBeforeToday = (d) => d instanceof Date && d.getTime() < startOfToday.getTime();

            const visitas = list.filter(ev => ev._taskType === 'visita');
            const outros = list.filter(ev => ev._taskType !== 'visita');

            const visitasPassadas = visitas.filter(ev => ev._date && isBeforeToday(ev._date));
            const visitasFuturas = visitas.filter(ev => !ev._date || !isBeforeToday(ev._date));

            const renderedEvents = [];
            const parts = [];

            function renderCards(label, items, extraClass, infoText){
                if (!items.length) return;
                const icon = extraClass === 'upcoming' ? 'fa-rocket' : extraClass === 'pending' ? 'fa-clock' : 'fa-circle';
                const stateLabel = extraClass === 'pending' ? 'Pendente' : 'Pr√≥ximo';
                const stateClass = extraClass === 'pending' ? 'state-pending' : 'state-upcoming';
                const infoIcon = infoText
                    ? `<span class="info-icon" title="${formatInfoTitle(infoText)}" aria-label="Informa√ß√µes sobre ${label}">‚ÑπÔ∏è</span>`
                    : '';
                parts.push(`
                    <section class="events-block">
                        <header class="events-header">
                            <div><i class="fas ${icon}"></i> ${label} ${infoIcon}</div>
                            <span class="meta">${items.length} evento(s)</span>
                        </header>
                        <div class="events-scroll">
                            <div class="event-card-grid">
                `);

                items.forEach(ev => {
                    const idx = renderedEvents.length;
                    renderedEvents.push(ev);

                    const d = ev._date;
                    const dataLabel = d ? formatDateBr(d) : 'Data n√£o informada';
                    const escola = ev.nome_da_escola || 'Escola n√£o informada';
                    const cidade = formatOrigemDestino(ev);
                    const conteudo = ev.conteudo_da_apresentacao || ev.conteudo_apresentacao || ev.conteudo || ev.apresentacao || '‚Äî';
                    const valor = formatCurrencyBR(ev.valor_total ?? ev.total ?? ev.valor ?? ev.custo_total);
                    const distancia = getDistanceLabel(ev);
                    const brindeField = (ev.brinde ?? ev.gift ?? '').toString().trim().toLowerCase();
                    const brindeOk = ['1','true','sim','yes','ok','s'].includes(brindeField);
                    const brindeLabel = brindeOk ? 'Brinde incluso' : 'Sem brinde';
                    const duracao = getDurationLabel(ev);
                    const diariasCount = getDiariasCount(ev);
                    const rotaContinua = ev.rota_continua === true || ev.rota_continua === 'true' || ev.rota_continua === 1;
                    const destLatVal = formatCoord(ev.destino_lat ?? ev.lat_destino ?? ev.latitude_destino);
                    const destLonVal = formatCoord(ev.destino_lon ?? ev.lon_destino ?? ev.longitude_destino);
                    const origLatVal = formatCoord(ev.origem_lat ?? ev.lat_origem ?? ev.latitude_origem);
                    const origLonVal = formatCoord(ev.origem_lon ?? ev.lon_origem ?? ev.longitude_origem);

                    parts.push(`
                        <div class="event-card ${ev.rota_continua && ev.blocoIndex != null ? ('rota-continua-bloco-' + (ev.blocoIndex % 3)) : ''}" data-ev-idx="${idx}">
                            <div class="event-card__header">
                                <div class="event-card__school">${escola}</div>
                                <div class="event-state ${stateClass}">${stateLabel}</div>
                            </div>
                        <div class="event-card__meta-row">
                            <div class="event-card__date"><i class="fas fa-calendar-day"></i>${dataLabel}</div>
                            <div class="event-card__chips" style="margin-top:0;">
                                <span class="chip ${brindeOk ? 'gold' : 'muted'}"><i class="fas fa-gift"></i>${brindeLabel}</span>
                                <span class="chip"><i class="fas fa-coins"></i>${valor}</span>
                                    <span class="chip"><i class="fas fa-route"></i>${distancia}</span>
                                    ${diariasCount ? `<span class="chip"><i class="fas fa-bed"></i>${diariasCount} di√°ria(s)</span>` : ''}
                                    <span class="chip"><i class="fas fa-clipboard-check"></i>${getResultadoLabel(ev)}</span>
                                    <span class="chip"><i class="fas fa-infinity"></i>${rotaContinua ? 'Rota cont√≠nua: Sim' : 'Rota cont√≠nua: N√£o'}</span>
                                    <span class="chip"><i class="fas fa-flag"></i>${formatTaskLabel(ev._taskType)}</span>
                            </div>
                        </div>
                        <div class="event-card__city">${cidade}</div>
                        <div class="event-card__chips">
                            <span class="chip"><i class="fas fa-meteor"></i>${conteudo}</span>
                            ${duracao ? `<span class="chip"><i class="fas fa-hourglass-half"></i>${duracao}</span>` : ''}
                        </div>
                        <div class="event-card__actions">
                            <button class="btn btn-secondary btn-compact" data-ev-action="despesas" data-ev-idx="${idx}">üí∞ Lan√ßar despesas</button>
                            <button class="btn btn-secondary btn-compact" data-ev-action="finalizar" data-ev-idx="${idx}">‚úÖ Finalizar</button>
                        </div>
                    </div>
                `);
            });

                parts.push(`
                            </div>
                        </div>
                    </section>
                `);
            }

            parts.push('<div class="events-container">');
            renderCards(
                'Pr√≥ximos Eventos',
                visitasFuturas,
                'upcoming',
                'Aqui voc√™ v√™ todos os eventos que ainda v√£o acontecer no futuro.\nSe n√£o houver eventos listados, significa que sua agenda est√° livre para novos compromissos.'
            );
            renderCards(
                'Eventos Pendentes de Finaliza√ß√£o',
                visitasPassadas,
                'pending',
                'Aqui ficam os eventos que j√° aconteceram ou que ainda n√£o possuem uma data definida.\nEsses eventos precisam ser finalizados ou organizados.'
            );
            parts.push('</div>');
            if (outros.length) {
                renderCards('Outros eventos', outros, 'other');
            }

            eventsListEl.innerHTML = parts.join('');

            // Clique para abrir modal e a√ß√µes nos cards
            const items = Array.from(eventsListEl.querySelectorAll('[data-ev-idx]'));
            items.forEach(item => {
                const idx = Number(item.dataset.evIdx);
                const ev = renderedEvents[idx];
                if (!ev) return;

                item.addEventListener('click', () => openEventModal(ev));

                const cardButtons = item.querySelectorAll('[data-ev-action]');
                cardButtons.forEach(btn => {
                    const action = btn.dataset.evAction;
                    btn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        if (action === 'despesas') {
                            lancarDespesas(ev, btn);
                        } else if (action === 'finalizar') {
                            finalizarEvento(ev, btn);
                        }
                    });
                });
            });
        }

        // ==== Carregar agenda do webhook (action=atualizar_agenda) ====
        async function carregarAgenda(){
            const sess = getLoggedSession();
            currentSession = sess;
            showDuplicates = false;
            const hasSession = !!(sess && sess.id_astronomo != null);
            statusTextEl.textContent = hasSession
                ? 'Conectando ao servidor...'
                : 'Sess√£o n√£o encontrada. Carregando agenda sem login...';
            btnRefreshAgenda.disabled = true;
                btnRefreshAgenda.textContent = 'Carregando...';
                if (btnOpenRotas) btnOpenRotas.disabled = true;

            try {
                const buildAgendaParams = () => {
                    const baseSess = buildSessionPayload(sess);
                    const params = {
                        action: 'atualizar_agenda',
                        tipo: getWebhookTipoFromSelect()
                    };
                    if (baseSess && baseSess.id_astronomo != null) params.id_astronomo = baseSess.id_astronomo;
                    if (baseSess && baseSess.usuario) params.usuario = baseSess.usuario;
                    const ids = getSessionTaskIds(baseSess || null);
                    if (ids && ids.visita) params.id_visita = ids.visita;
                    if (ids && ids.pre) params.id_pre = ids.pre;
                    if (ids && ids.reserva) params.id_reserva = ids.reserva;
                    if (ids && ids.nao_marcar) params.id_n_marcar = ids.nao_marcar;
                    return params;
                };

                const payload = buildAgendaParams();
                const url = API_AGENDA;

                let data = null;

                // 1¬™ tentativa: POST (padr√£o do webhook)
                try {
                    const resp = await fetch(url, {
                        method: 'POST',
                        headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (resp && resp.ok) {
                        data = await readResponsePayload(resp);
                    } else {
                        const txt = resp ? await resp.text().catch(()=>'') : '';
                        throw new Error(`HTTP ${resp ? resp.status : '??'}: ${txt || 'erro'}`);
                    }
                } catch (err) {
                    throw err;
                }

                if (!data) {
                    data = [];
                }

                saveAgendaPayload(data, sess);

                const rawEventos = normalizeAgendaPayload(data);
                if ((!rawEventos || !rawEventos.length) && typeof showNoDataPopup === 'function') {
                    showNoDataPopup('Sem dados retornados do n8n.');
                }

                eventsDataRaw = rawEventos.map(ev => normalizeEvent(ev, sess));
                eventsData = dedupeEventsById(eventsDataRaw);
                const ignoredCount = Math.max(0, eventsDataRaw.length - eventsData.length);
                applyRotaContinuaBlocks(eventsData);
                applyRouteOverrides(eventsData, sess);
                saveAgendaCache(eventsData, sess);
                syncRotasCache(eventsData, sess);
                if (btnOpenRotas) btnOpenRotas.disabled = false;
                // redefine filtro (ids podem mudar conforme login)
                if (taskTypeFilterEl) {
                    currentTaskFilter = getSelectedTaskFilter();
                }

                statusTextEl.textContent = `Agenda carregada: ${eventsData.length} evento(s).`;
                showDuplicatePopup(ignoredCount);
                if (!selectedDate || !(selectedDate instanceof Date) || Number.isNaN(selectedDate.getTime())) {
                    const firstEvent = eventsData
                        .map(ev => ev && ev._date)
                        .filter(d => d instanceof Date && !Number.isNaN(d.getTime()))
                        .sort((a, b) => a - b)[0];
                    const baseDate = firstEvent ? startOfDay(firstEvent) : startOfDay(new Date());
                    selectedDate = baseDate;
                    currentMonthDate = baseDate;
                } else {
                    selectedDate = startOfDay(selectedDate);
                }
                renderCalendar();
                renderEventsList();
                renderDayEventsDetails();

                computeContinuousRoutes(eventsData)
                    .then(metrics => {
                        applyContinuousRouteMetrics(eventsData, metrics);
                        renderEventsList();
                        renderDayEventsDetails();
                    })
                    .catch(err => console.warn('Erro ao calcular rota cont√≠nua OSRM:', err));
            } catch (err) {
                console.error('Erro ao carregar agenda:', err);
                statusTextEl.textContent = 'Erro ao carregar agenda: ' + (err && err.message || err);
                eventsListEl.innerHTML = `
                    <div class="empty-state">
                        Erro ao buscar dados do webhook. Tente novamente.
                    </div>
                `;
            } finally {
                btnRefreshAgenda.disabled = false;
                btnRefreshAgenda.textContent = 'üîÑ Atualizar agenda';
            }
        }

        // ==== Inicializa√ß√£o ====
        function goToRotas(){
            const sess = getLoggedSession() || currentSession;
            syncRotasCache(eventsData, sess);
            window.location.href = 'rotas.html';
        }

        document.addEventListener('DOMContentLoaded', () => {
            const sess = getLoggedSession();
            currentSession = sess;
            if (!sess || sess.id_astronomo == null) {
                astroInfoEl.textContent = 'Nenhum astr√¥nomo logado.';
            } else {
                astroInfoEl.textContent = describeSession(sess);
            }

            taskTypeFilterEl.addEventListener('change', () => {
                currentTaskFilter = getSelectedTaskFilter();
                renderCalendar();
                renderEventsList();
                renderDayEventsDetails();
            });

            btnRefreshAgenda.addEventListener('click', () => {
                carregarAgenda();
            });

            if (btnOpenRotas) {
                btnOpenRotas.addEventListener('click', goToRotas);
                // Habilita se j√° existe cache anterior
                try{
                    const cacheKey = agendaCacheKey(sess);
                        const rawCache = cacheKey ? localStorage.getItem(cacheKey) : null;
                        const parsed = rawCache ? JSON.parse(rawCache) : null;
                        if (parsed && Array.isArray(parsed.events) && parsed.events.length) {
                            eventsDataRaw = parsed.events.map(ev => normalizeEvent(ev, sess));
                            eventsData = dedupeEventsById(eventsDataRaw);
                            const ignoredCount = Math.max(0, eventsDataRaw.length - eventsData.length);
                            applyRotaContinuaBlocks(eventsData);
                            applyRouteOverrides(eventsData, sess);
                            syncRotasCache(eventsData, sess);
                            btnOpenRotas.disabled = false;
                            showDuplicatePopup(ignoredCount);
                            computeContinuousRoutes(eventsData)
                                .then(metrics => {
                                    applyContinuousRouteMetrics(eventsData, metrics);
                                    renderEventsList();
                                    renderDayEventsDetails();
                                })
                                .catch(err => console.warn('Erro ao calcular rota cont√≠nua OSRM (cache):', err));
                        }
                }catch(_){}
            }

            btnPrevMonth.addEventListener('click', () => {
                currentMonthDate = new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth() - 1, 1);
                renderCalendar();
            });

            btnNextMonth.addEventListener('click', () => {
                currentMonthDate = new Date(currentMonthDate.getFullYear(), currentMonthDate.getMonth() + 1, 1);
                renderCalendar();
            });

            if (eventModalClose) eventModalClose.addEventListener('click', closeEventModal);
            if (eventModalBackdrop) eventModalBackdrop.addEventListener('click', closeEventModal);
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') closeEventModal();
            });
            if (lightboxClose) lightboxClose.addEventListener('click', closeImageLightbox);
            if (lightboxBackdrop) lightboxBackdrop.addEventListener('click', closeImageLightbox);
            if (lightboxNext) lightboxNext.addEventListener('click', nextLightboxImage);
            if (lightboxPrev) lightboxPrev.addEventListener('click', prevLightboxImage);

            updateTaskFilterLabels(sess);
            // for√ßa estado inicial para VISITA
            const savedUI = loadIndexUIState();
            if (taskTypeFilterEl) {
                if (savedUI && savedUI.taskFilter) {
                    taskTypeFilterEl.value = savedUI.taskFilter;
                } else {
                    const visitaOpt = taskTypeFilterEl.querySelector('option[data-type="visita"]');
                    if (visitaOpt) visitaOpt.selected = true;
                }
            }
            currentTaskFilter = getSelectedTaskFilter();

            // Estado inicial do calend√°rio (antes de ter eventos)
            const today = startOfDay(new Date());
            currentMonthDate = today;
            selectedDate = today;
            renderCalendar();
            renderEventsList(); // mostra vazio
            renderDayEventsDetails();

            // Carrega agenda imediatamente
            carregarAgenda();
        });

        // ================================
        //  ROTA CONT√çNUA (sem IA em runtime)
        // ================================
        const ROUTE_CACHE_KEY = 'route_cache_osrm_v1';
        const COORD_CACHE_KEY = 'coord_cache_nominatim_v1';

        function loadCache(key){
            try{ return JSON.parse(localStorage.getItem(key)||'{}'); }catch(_){ return {}; }
        }
        function saveCache(key,obj){
            try{ localStorage.setItem(key, JSON.stringify(obj||{})); }catch(_){}
        }

        function buildRouteCacheId(aLat,aLon,bLat,bLon){
            return [Number(aLat).toFixed(5), Number(aLon).toFixed(5), Number(bLat).toFixed(5), Number(bLon).toFixed(5)].join('|');
        }

        async function delay(ms){ return new Promise(res=>setTimeout(res, ms)); }

        async function getCoordinates(cityName){
            if (!cityName) return null;
            const cache = loadCache(COORD_CACHE_KEY);
            const key = cityName.toLowerCase();
            if (cache[key]) return cache[key];
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(cityName)}&limit=1`;
            const resp = await fetch(url, { headers:{'Accept':'application/json'}, method:'GET' });
            if (!resp.ok) throw new Error('Nominatim error');
            const data = await resp.json();
            const hit = Array.isArray(data) && data[0] ? { lat: Number(data[0].lat), lon: Number(data[0].lon) } : null;
            cache[key] = hit;
            saveCache(COORD_CACHE_KEY, cache);
            await delay(1000);
            return hit;
        }

        async function getRoute(lat1, lon1, lat2, lon2){
            const cache = loadCache(ROUTE_CACHE_KEY);
            const id = buildRouteCacheId(lat1,lon1,lat2,lon2);
            if (cache[id]) return cache[id];
            const url = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=false&geometries=geojson&alternatives=false&steps=false`;
            const resp = await fetch(url, { headers:{'Accept':'application/json'}, method:'GET' });
            if (!resp.ok) throw new Error('OSRM error');
            const data = await resp.json();
            const route = data && data.routes && data.routes[0] ? {
                distance_km: (data.routes[0].distance || 0) / 1000,
                duration_h: (data.routes[0].duration || 0) / 3600
            } : null;
            cache[id] = route;
            saveCache(ROUTE_CACHE_KEY, cache);
            await delay(1000);
            return route;
        }

        function parseDay(dateStr){
            if (!dateStr) return null;
            const d = new Date(dateStr);
            if (Number.isNaN(d.getTime())) return null;
            return new Date(d.getFullYear(), d.getMonth(), d.getDate());
        }

        function daysBetween(d1,d2){
            const ms = d2.getTime() - d1.getTime();
            return Math.round(ms / 86400000);
        }

        function detectContinuousRoutes(events){
            if (!Array.isArray(events)) return [];
            // j√° ordenados por data (garantia do backend/agenda)
            const groups = [];
            let current = [];
            const isLongTrip = (ev) => {
                const dist = getDistanceKmValue(ev);
                return dist !== null && dist > 250;
            };

            for (let i=0;i<events.length;i++){
                const ev = events[i];
                const day = parseDay(ev.data_e_hora_agendamento || ev.data_e_hora_do_agendamento || ev.data_agendamento || ev.data || ev._date);
                if (!day || !isLongTrip(ev)) {
                    if (current.length > 0) { groups.push(current.slice()); current = []; }
                    continue;
                }
                const next = events[i+1];
                if (next) {
                    const nextDay = parseDay(next.data_e_hora_agendamento || next.data_e_hora_do_agendamento || next.data_agendamento || next.data || next._date);
                    const consecutive = nextDay && day && daysBetween(day, nextDay) === 1;
                    const nextLong = isLongTrip(next);
                    if (consecutive && nextLong) {
                        current.push(ev);
                        continue;
                    }
                }
                // fecha bloco (inclui atual se n√£o entrou acima)
                current.push(ev);
                if (current.length > 0) { groups.push(current.slice()); current = []; }
            }
            if (current.length) groups.push(current);
            return groups.filter(g => g.length > 1);
        }

        async function calculateContinuousRouteGroups(groups){
            if (!Array.isArray(groups) || !groups.length) return [];
            const results = [];
            for (const group of groups){
                if (!group.length) continue;
                const baseLat = Number(group[0].origem_lat ?? group[0].lat_origem ?? group[0].latitude_origem);
                const baseLon = Number(group[0].origem_lon ?? group[0].lon_origem ?? group[0].longitude_origem);
                const routes = [];
                // Base -> primeiro
                if (Number.isFinite(baseLat) && Number.isFinite(baseLon)){
                    const r = await getRoute(baseLat, baseLon, Number(group[0].destino_lat), Number(group[0].destino_lon));
                    routes.push({ from:'base', to: group[0].id || 0, ...r });
                }
                // Entre eventos
                for (let i=0;i<group.length-1;i++){
                    const a = group[i];
                    const b = group[i+1];
                    const r = await getRoute(Number(a.destino_lat), Number(a.destino_lon), Number(b.destino_lat), Number(b.destino_lon));
                    routes.push({ from: a.id || i, to: b.id || (i+1), ...r });
                }
                // √öltimo -> base
                const last = group[group.length-1];
                if (Number.isFinite(baseLat) && Number.isFinite(baseLon)){
                    const r = await getRoute(Number(last.destino_lat), Number(last.destino_lon), baseLat, baseLon);
                    routes.push({ from: last.id || group.length-1, to:'base', ...r });
                }
                results.push({ events: group, routes });
            }
            return results;
        }

        // ==== L√ìGICA CORRIGIDA DE ROTA CONT√çNUA ====
        function applyRotaContinuaBlocks(events) {
            if (!Array.isArray(events)) return [];
            
            // Limpa flags anteriores
            events.forEach(ev => { 
                ev.rota_continua = false; 
                ev.blocoIndex = null;
                ev._rota_idx = null;
                ev._rota_total = null;
            });

            // Filtra e ordena eventos futuros
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const sorted = events
                .filter(ev => {
                    const date = getEventDate(ev);
                    return date && date >= today;
                })
                .sort((a, b) => {
                    const dateA = getEventDate(a);
                    const dateB = getEventDate(b);
                    return dateA - dateB;
                });

            const blocos = [];
            let blocoAtual = [];

            for (let i = 0; i < sorted.length; i++) {
                const atual = sorted[i];
                
                // Verifica se √© candidato a iniciar/bloco
                const isCandidate = isLongTrip(atual) || atual.precisa_voltar_para_base === false;
                
                if (!isCandidate) {
                    // Finaliza bloco atual se existir
                    if (blocoAtual.length >= 2) {
                        blocos.push([...blocoAtual]);
                    }
                    blocoAtual = [];
                    continue;
                }

                if (blocoAtual.length === 0) {
                    // Inicia novo bloco
                    blocoAtual.push(atual);
                } else {
                    const ultimoBloco = blocoAtual[blocoAtual.length - 1];
                    const isConsecutive = areEventsConsecutive(ultimoBloco, atual);
                    
                    if (isConsecutive) {
                        blocoAtual.push(atual);
                    } else {
                        // Finaliza bloco atual e inicia novo
                        if (blocoAtual.length >= 2) {
                            blocos.push([...blocoAtual]);
                        }
                        blocoAtual = [atual];
                    }
                }
            }

            // Finaliza √∫ltimo bloco
            if (blocoAtual.length >= 2) {
                blocos.push([...blocoAtual]);
            }

            // Aplica flags aos eventos
            blocos.forEach((bloco, blocoIndex) => {
                bloco.forEach((evento, eventoIndex) => {
                    evento.rota_continua = true;
                    evento.blocoIndex = blocoIndex;
                    evento._rota_idx = eventoIndex + 1;
                    evento._rota_total = bloco.length;
                    evento._rota_colorIndex = blocoIndex % 3;
                });
            });

            return blocos;
        }

        // Fun√ß√µes auxiliares
        function isLongTrip(event) {
            const dist = getDistanceKmValue(event);
            return dist !== null && dist >= 250;
        }

        function getEventDate(event) {
            const raw = event.data_e_hora_agendamento || event.data_e_hora_do_agendamento || event.data_agendamento || event.data || event._date;
            if (!raw) return null;
            const d = new Date(raw);
            return Number.isNaN(d.getTime()) ? null : d;
        }

        function areEventsConsecutive(eventA, eventB) {
            const dateA = getEventDate(eventA);
            const dateB = getEventDate(eventB);
            
            if (!dateA || !dateB) return false;

            // Considera di√°rias do evento A
            const diarias = Number(eventA.numero_de_diarias ?? eventA.diarias ?? 1);
            const endDateA = new Date(dateA);
            endDateA.setDate(endDateA.getDate() + diarias - 1);

            // Data B deve ser dia seguinte ao t√©rmino de A
            const expectedDateB = new Date(endDateA);
            expectedDateB.setDate(expectedDateB.getDate() + 1);

            return dateB.toDateString() === expectedDateB.toDateString();
        }

        function applyRouteOverrides(events, sess){
            if (!Array.isArray(events)) return;
            const data = loadRouteOverrides(sess);
            const overrides = (data && data.overrides) || {};
            events.forEach(ev => {
                const id = getEventId(ev);
                const key = id != null ? String(id) : null;
                const dist = key && Object.prototype.hasOwnProperty.call(overrides, key) ? overrides[key] : null;
                if (dist !== null && dist !== undefined && Number.isFinite(Number(dist))) {
                    ev._dist_override_km = Number(dist);
                } else {
                    ev._dist_override_km = null;
                }
            });
        }
        // ==== Nova l√≥gica de rota cont√≠nua baseada em dias consecutivos e dist√¢ncia ====
        const ROUTE_BLOCK_CACHE_KEY = 'route_block_cache_v1';

        function startOfDay(d){
            return new Date(d.getFullYear(), d.getMonth(), d.getDate());
        }

        function normalizeDate(val){
            if (val instanceof Date) return startOfDay(val);
            const d = new Date(val);
            if (Number.isNaN(d.getTime())) return null;
            return startOfDay(d);
        }

        function isFutureOrToday(d){
            const today = startOfDay(new Date());
            return d && d.getTime() >= today.getTime();
        }

        function isCandidate(ev){
            const dist = getDistanceKmValue(ev);
            const longTrip = dist !== null && dist >= 250;
            const noReturn = ev.precisa_voltar_para_base === false;
            return longTrip || noReturn;
        }

        function applyContinuousFlags(events){
            if (!Array.isArray(events)) return { blocks: [], byId: {} };
            // zera flags
            events.forEach(ev => { ev.rota_continua = false; ev._rota_idx = null; ev._rota_total = null; });

            // filtra futuros
            const future = events
                .map(ev => ({ ev, day: normalizeDate(ev.data_e_hora_agendamento || ev.data_e_hora_do_agendamento || ev.data || ev.data_agendamento || ev._date) }))
                .filter(v => v.day && isFutureOrToday(v.day))
                .sort((a,b)=> a.day - b.day);

            const blocks = [];
            let i = 0;
            while (i < future.length){
                const cur = future[i];
                if (!isCandidate(cur.ev)) { i++; continue; }
                const block = [cur];
                while (i + 1 < future.length){
                    const next = future[i+1];
                    if (!isCandidate(next.ev)) break;
                    const diff = (next.day - cur.day) / 86400000;
                    if (diff === 1) {
                        block.push(next);
                        i++;
                        cur.day = next.day;
                        cur.ev = next.ev;
                        continue;
                    }
                    break;
                }
                // fecha bloco
                if (block.length >= 2) {
                    blocks.push(block);
                    block.forEach((item, idx) => {
                        item.ev.rota_continua = true;
                        item.ev._rota_idx = idx + 1;
                        item.ev._rota_total = block.length;
                    });
                }
                i++;
            }

            const byId = {};
            blocks.forEach((block, bi) => {
                block.forEach(({ev}) => { byId[getEventId(ev)] = bi; });
            });
            return { blocks, byId };
        }

        async function getMultiRoute(coordsKey, coords){
            const cache = loadCache(ROUTE_BLOCK_CACHE_KEY);
            if (cache[coordsKey]) return cache[coordsKey];
            const url = `https://router.project-osrm.org/route/v1/driving/${coords.join(';')}?overview=false&annotations=distance,duration&alternatives=false&steps=false`;
            const resp = await fetch(url, { headers:{'Accept':'application/json'}, method:'GET' });
            if (!resp.ok) throw new Error('OSRM error');
            const data = await resp.json();
            cache[coordsKey] = data;
            saveCache(ROUTE_BLOCK_CACHE_KEY, cache);
            await delay(1000);
            return data;
        }

        async function computeContinuousRoutes(events){
            const blocks = applyRotaContinuaBlocks(events);
            const results = [];
            for (const block of blocks){
                const evs = block.map(b => b.ev);
                if (!evs.length) continue;
                const baseLat = Number(evs[0].origem_lat ?? evs[0].lat_origem ?? evs[0].latitude_origem);
                const baseLon = Number(evs[0].origem_lon ?? evs[0].lon_origem ?? evs[0].longitude_origem);
                if (!Number.isFinite(baseLat) || !Number.isFinite(baseLon)) continue;

                const coords = [];
                coords.push(`${baseLon},${baseLat}`);
                evs.forEach(ev => {
                    const dLat = Number(ev.destino_lat);
                    const dLon = Number(ev.destino_lon);
                    if (Number.isFinite(dLat) && Number.isFinite(dLon)) coords.push(`${dLon},${dLat}`);
                });
                coords.push(`${baseLon},${baseLat}`);

                if (coords.length < 3) continue;
                const coordsKey = coords.join('|');
                const data = await getMultiRoute(coordsKey, coords);
                const legs = (data && data.routes && data.routes[0] && data.routes[0].legs) || [];
                const mappedLegs = [];
                let totalDist = 0;
                let totalDur = 0;
                for (let i=0;i<legs.length;i++){
                    const leg = legs[i];
                    const distKm = (leg.distance || 0) / 1000;
                    const durH = (leg.duration || 0) / 3600;
                    totalDist += distKm;
                    totalDur += durH;
                    const fromLabel = i === 0 ? 'BASE' : getEventId(evs[i-1]);
                    const toLabel = i < evs.length ? getEventId(evs[i]) : 'BASE';
                    mappedLegs.push({ from: fromLabel, to: toLabel, distancia_km: Number(distKm.toFixed(2)), duracao_h: Number(durH.toFixed(2)) });
                }
                results.push({
                    eventos: evs,
                    legs: mappedLegs,
                    distancia_total_km: Number(totalDist.toFixed(2)),
                    duracao_total_h: Number(totalDur.toFixed(2))
                });
            }
            return results;
        }

        function applyContinuousRouteMetrics(events, metrics){
            if (!Array.isArray(metrics) || !Array.isArray(events)) return;
            const byId = new Map();
            events.forEach(ev => { const id = getEventId(ev); if (id != null) byId.set(String(id), ev); });

            metrics.forEach(block => {
                const { eventos, legs } = block || {};
                if (!Array.isArray(eventos) || !Array.isArray(legs)) return;
                eventos.forEach((ev, idx) => {
                    const leg = legs[idx];
                    const evId = getEventId(ev);
                    if (!leg || evId == null) return;
                    const target = byId.get(String(evId));
                    if (!target) return;
                    // Dist√¢ncia: primeiro evento usa base->evento, intermedi√°rios usam perna OSRM,
                    // √∫ltimo evento pode usar a dist√¢ncia original do n8n (base <-> evento) para o trecho de volta.
                    const isLast = idx === eventos.length - 1;
                    const distN8n = getDistanceKmValue(target, false);
                    if (Number.isFinite(leg.distancia_km)) {
                        target._dist_override_km = isLast && Number.isFinite(distN8n) ? distN8n : leg.distancia_km;
                    }
                    if (Number.isFinite(leg.duracao_h)) {
                        target._dur_override_h = leg.duracao_h;
                    }
                });
            });
        }

        function rotaEventoId(ev){
            return ev && (ev.id_evento || ev.id_evento_unico || ev.id_agendamento || ev.id || ev.uuid || ev.evento_id);
        }

        function rotaEventoCoords(ev){
            const lat = toNumber(ev?.destino_lat ?? ev?.lat_destino ?? ev?.latitude_destino ?? ev?.lat);
            const lon = toNumber(ev?.destino_lon ?? ev?.lon_destino ?? ev?.longitude_destino ?? ev?.lon);
            if (lat === null || lon === null) return null;
            return { lat, lon };
        }

        function rotaPertenceASessao(rota, sess){
            if (!rota || !sess) return false;
            const rotaId = rota.id_astronomo ?? rota.astronomo_id ?? rota.astronomer_id ?? rota.usuario_id ?? rota.user_id;
            if (rotaId != null && sess.id_astronomo != null) {
                return String(rotaId) === String(sess.id_astronomo);
            }
            const rotaNome = (rota.astronomo || rota.usuario || rota.nome || rota.nome_completo || '').toString().toLowerCase();
            const sessNome = (sess.usuario || sess.username || sess.astronomo || '').toString().toLowerCase();
            if (rotaNome && sessNome) return rotaNome === sessNome;
            return true;
        }

        function buildOverridesFromRota(rota, continuousIds){
            const overrides = {};
            const eventos = Array.isArray(rota?.eventos) ? rota.eventos.slice() : [];
            if (!eventos.length) return overrides;

            eventos.sort((a,b) => {
                const da = getEventDate(a);
                const db = getEventDate(b);
                if (!da || !db) return 0;
                return da - db;
            });

            const rotaContinua = rota?.rota_continua === true || rota?.continua === true || (rota?.tipo || '').toString().toLowerCase().includes('continua');

            for (let i = 1; i < eventos.length; i++){
                const atual = eventos[i];
                const anterior = eventos[i-1];
                const evId = rotaEventoId(atual);
                const prevId = rotaEventoId(anterior);
                const marcadoContinua = rotaContinua ||
                    (continuousIds && continuousIds.has(String(evId))) ||
                    (continuousIds && continuousIds.has(String(prevId))) ||
                    atual?.rota_continua === true ||
                    anterior?.rota_continua === true;
                if (!marcadoContinua || evId == null) continue;

                const coordPrev = rotaEventoCoords(anterior);
                const coordCur = rotaEventoCoords(atual);
                let dist = null;
                if (coordPrev && coordCur) {
                    dist = computeDistanceKm(coordPrev.lat, coordPrev.lon, coordCur.lat, coordCur.lon);
                } else {
                    const raw = toNumber(atual.distancia_rota_continua ?? atual.distancia_rota ?? atual.distancia_entre_eventos);
                    dist = raw;
                }
                if (dist !== null && Number.isFinite(dist) && dist > 0) {
                    overrides[String(evId)] = Number(dist.toFixed(2));
                }
            }
            return overrides;
        }

        async function fetchRotasSessao(sess){
            if (!sess) return null;
            const buildUrl = () => {
                const u = new URL(API_AGENDA);
                u.searchParams.set('tipo', 'TODOS');
                if (sess.id_astronomo != null) u.searchParams.set('id_astronomo', String(sess.id_astronomo));
                if (sess.usuario) u.searchParams.set('usuario', String(sess.usuario));
                return u.toString();
            };

            let data = null;
            let lastErr = null;

            try{
                const url = buildUrl();
                const resp = await fetch(url, { method:'POST', headers:{'Accept':'application/json'} });
                if (resp && resp.ok) {
                    data = await readResponsePayload(resp);
                } else {
                    const txt = resp ? await resp.text().catch(()=>'') : '';
                    throw new Error(`HTTP ${resp ? resp.status : '??'}: ${txt || 'erro'}`);
                }
            }catch(err){
                lastErr = err;
            }

            if (!data){
                try{
                    const url = buildUrl();
                    const resp = await fetch(url, { method:'GET', headers:{'Accept':'application/json'} });
                    if (resp && resp.ok) {
                        data = await readResponsePayload(resp);
                    } else {
                        const txt = resp ? await resp.text().catch(()=>'') : '';
                        throw new Error(`HTTP ${resp ? resp.status : '??'}: ${txt || 'erro'}`);
                    }
                }catch(err){
                    lastErr = err;
                }
            }

            if (!data) {
                if (lastErr) throw lastErr;
                return null;
            }

            if (Array.isArray(data)) return data;
            if (Array.isArray(data.rotas)) return data.rotas;
            if (Array.isArray(data.data)) return data.data;
            return [];
        }

        async function refreshRotasOverrides(sess, events){
            try{
                const rotas = await fetchRotasSessao(sess);
                if (!Array.isArray(rotas) || !rotas.length) return null;
                const idsRotaContinua = new Set(
                    (events || [])
                        .filter(ev => ev && ev.rota_continua)
                        .map(ev => String(getEventId(ev)))
                );
                const overrides = {};
                rotas
                    .filter(rota => rotaPertenceASessao(rota, sess))
                    .forEach(rota => Object.assign(overrides, buildOverridesFromRota(rota, idsRotaContinua)));

                if (Object.keys(overrides).length) {
                    return saveRouteOverrides(overrides, sess);
                }
            }catch(err){
                console.warn('Falha ao atualizar rotas cont√≠nuas do webhook:', err);
            }
            return null;
        }
        // Exponibiliza utilit√°rio para outras p√°ginas (reutiliza cache salvo)
        window.detectContinuousRoutes = detectContinuousRoutes;
        window.calculateContinuousRouteGroups = calculateContinuousRouteGroups;
    </script>
</body>
</html>
